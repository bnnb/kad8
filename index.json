


[{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/series/cpu/","section":"Series","summary":"","title":"CPU","type":"series"},{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/hardware/","section":"Hardwares","summary":"","title":"Hardwares","type":"hardware"},{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/tags/hbm4/","section":"Tags","summary":"","title":"HBM4","type":"tags"},{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-10-13","externalUrl":null,"permalink":"/tags/tsmc/","section":"Tags","summary":"","title":"TSMC","type":"tags"},{"content":"台积电HBM4内存的推出将带来多项重大变革，其中最引人注目的就是其内存接口的大幅扩展。第四代内存技术接口从1024位扩展到2048位，这标志着HBM4内存的设计和生产将面临新的挑战，为了适应这一变化，芯片制造商必须采用更新、更高级的封装技术。\n在2024年的欧洲技术研讨会上，台积电透露了其为HBM4制造的base die一些细节，这些芯片将采用逻辑工艺制造，台积电计划利用其N12和N5工艺的改进版本来生产这些芯片。这将使台积电在HBM4的生产领域占据优势，因为现有的内存制造设施均无法做到经济高效地生产这种先进逻辑芯片。\n对于HBM4的首批产品封装，台积电将采用N12FFC+和N5两种不同的制造工艺。尽管这两种工艺都是为了将HBM4E内存与新一代的AI和高性能计算处理器相结合，但它们在连接AI和高性能计算应用的高性能处理器的内存方面发挥着不同的作用。\n台积电的设计和技术平台高级总监透露：“公司正与美光、三星和SK海力士等主要HBM内存供应商合作，利用先进的工艺节点推进HBM4内存技术的全面整合。N12FFC+工艺的基础芯片在成本效益上具有优势，能够满足HBM的性能需求，而N5工艺的基础芯片则能在保持HBM4速度的同时，提供更复杂的逻辑功能并大幅降低能耗。\n台积电的N12FFC+工艺（12纳米FinFET Compact Plus，虽然归类于12纳米技术，但技术基础源自其成熟的16纳米FinFET生产线）生产的基础芯片，将用于在系统级芯片（SoCs）旁的硅中介层上安装HBM4内存堆栈。台积电相信，其12FFC+工艺非常适合实现HBM4的性能，使内存制造商能够构建12-Hi（48GB）和16-Hi（64GB）堆栈，每个堆栈的带宽超过2TB/秒。\n台积电高级总监提到：“我们也在为HBM4优化CoWoS-L和CoWoS-R技术，CoWoS-L和CoWoS-R技术都采用超过八层的布线设计以确保HBM4超过2000个的互连和信号完整性。”\n使用N12FFC+工艺的HBM4基础芯片对于采用台积电CoWoS-L或CoWoS-R先进封装技术构建系统级封装（SiPs）至关重要，这些技术提供的中介层面积可达8倍光罩尺寸，足以容纳多达12个HBM4内存堆栈。据报道，HBM4能够以 14mA的电流实现6GT/s的数据传输速率。\n台积电还与Cadence、Synopsys和Ansys等EDA公司合作，确保HBM4通道的信号完整性、IR/EM和热准确性。\n与此同时，内存制造商还可以选择使用台积电的N5工艺来生产HBM4 base die。N5工艺制造的基础芯片将集成更多逻辑功能，减少功耗并提供更高的性能。最重要的是，这种先进的工艺技术将实现非常小的互连间距，约为6到9微米，这将使N5基础芯片能够与直接键合技术结合使用，允许HBM4直接3D堆叠在逻辑芯片上从而大幅提升内存性能，这将为不断追求更高内存带宽的AI和HPC芯片带来巨大的提升。\n据悉，台积电与SK海力士在HBM4 base die上已有合作，并且台积电也可能为美光生产HBM4 base die。至于三星拥有自己的先进逻辑生产线，台积电与其合作的可能性相对较小。\n","date":"2024-10-13","externalUrl":null,"permalink":"/hardware/tsmc-readies-hbm4-base-dies-at-12nm-and-5nm/","section":"Hardwares","summary":"\u003cp\u003e台积电HBM4内存的推出将带来多项重大变革，其中最引人注目的就是其内存接口的大幅扩展。第四代内存技术接口从1024位扩展到2048位，这标志着HBM4内存的设计和生产将面临新的挑战，为了适应这一变化，芯片制造商必须采用更新、更高级的封装技术。\u003c/p\u003e\n\u003cp\u003e在2024年的欧洲技术研讨会上，台积电透露了其为HBM4制造的base die一些细节，这些芯片将采用逻辑工艺制造，台积电计划利用其N12和N5工艺的改进版本来生产这些芯片。这将使台积电在HBM4的生产领域占据优势，因为现有的内存制造设施均无法做到经济高效地生产这种先进逻辑芯片。\u003c/p\u003e\n\u003cp\u003e对于HBM4的首批产品封装，台积电将采用N12FFC+和N5两种不同的制造工艺。尽管这两种工艺都是为了将HBM4E内存与新一代的AI和高性能计算处理器相结合，但它们在连接AI和高性能计算应用的高性能处理器的内存方面发挥着不同的作用。\u003c/p\u003e\n\u003cp\u003e台积电的设计和技术平台高级总监透露：“公司正与美光、三星和SK海力士等主要HBM内存供应商合作，利用先进的工艺节点推进HBM4内存技术的全面整合。N12FFC+工艺的基础芯片在成本效益上具有优势，能够满足HBM的性能需求，而N5工艺的基础芯片则能在保持HBM4速度的同时，提供更复杂的逻辑功能并大幅降低能耗。\u003c/p\u003e\n\u003cp\u003e\n    \u003cfigure\u003e\n      \u003cimg class=\"my-0 rounded-md\" loading=\"lazy\" src=\"./TSMC-Logic-for-HBM4-Base-Die.png\" alt=\"TSMC Logic for HBM4 Base Die\" /\u003e\n      \n    \u003c/figure\u003e\n\u003c/p\u003e\n\u003cp\u003e台积电的N12FFC+工艺（12纳米FinFET Compact Plus，虽然归类于12纳米技术，但技术基础源自其成熟的16纳米FinFET生产线）生产的基础芯片，将用于在系统级芯片（SoCs）旁的硅中介层上安装HBM4内存堆栈。台积电相信，其12FFC+工艺非常适合实现HBM4的性能，使内存制造商能够构建12-Hi（48GB）和16-Hi（64GB）堆栈，每个堆栈的带宽超过2TB/秒。\u003c/p\u003e\n\u003cp\u003e台积电高级总监提到：“我们也在为HBM4优化CoWoS-L和CoWoS-R技术，CoWoS-L和CoWoS-R技术都采用超过八层的布线设计以确保HBM4超过2000个的互连和信号完整性。”\u003c/p\u003e\n\u003cp\u003e使用N12FFC+工艺的HBM4基础芯片对于采用台积电CoWoS-L或CoWoS-R先进封装技术构建系统级封装（SiPs）至关重要，这些技术提供的中介层面积可达8倍光罩尺寸，足以容纳多达12个HBM4内存堆栈。据报道，HBM4能够以 14mA的电流实现6GT/s的数据传输速率。\u003c/p\u003e\n\u003cp\u003e台积电还与Cadence、Synopsys和Ansys等EDA公司合作，确保HBM4通道的信号完整性、IR/EM和热准确性。\u003c/p\u003e\n\u003cp\u003e与此同时，内存制造商还可以选择使用台积电的N5工艺来生产HBM4 base die。N5工艺制造的基础芯片将集成更多逻辑功能，减少功耗并提供更高的性能。最重要的是，这种先进的工艺技术将实现非常小的互连间距，约为6到9微米，这将使N5基础芯片能够与直接键合技术结合使用，允许HBM4直接3D堆叠在逻辑芯片上从而大幅提升内存性能，这将为不断追求更高内存带宽的AI和HPC芯片带来巨大的提升。\u003c/p\u003e","title":"台积电要用5nm先进封装HBM4内存芯片","type":"hardware"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/tags/altera/","section":"Tags","summary":"","title":"Altera","type":"tags"},{"content":" Purpose of this Article # This article describes how to take a VxWorks® bootrom that is built using the Wind River® BSP, alt_soc_gen5, combine it with a preloader built from an Altera® FPGA design, and boot the Altera Cyclone® V and Arria® V SoC development boards using QSPI or SD/MMC.\nNote: This document does not cover how to configure or build the Altera preloader or VxWorks bootrom. What is Needed to Build this System # The following is needed to build this system:\nAn Altera Cyclone V or Arria V SoC development board to run the software. A Wind River workbench development environment and license to build the VxWorks bootrom. An SD/MMC card to hold the boot software for SD/MMC or help program QSPI. Alternatively, you can use the Altera Quartus programmer to program QSPI instead of programming through the SD/MMC. The Win32 Disk Imager program to write the image to an SD/MMC card. You can also use the Linux program dd, but be careful with the device name. You can download the Windows tool from the Sourceforge® website. This package contains pre-built binaries to get started, including:\nPrebuilt SD/MMC images for Cyclone V and Arria V development boards. Prebuilt preloader images for both QSPI and SD/MMC and for both Cyclone V and Arria V development boards. Prebuilt version of the linux utility mkimage for Windows, used to wrap the VxWorks bootrom with the proper header. This release also contains a script, make_sdimage.sh, to help create a new SD/MMC image on a linux system.\nThese instructions are tested with, the following:\nAltera Cyclone V SoC Revision C development board Wind River Workbench version 3.3.4 and VxWorks versions 6.9.3.2 alt_soc_gen5 BSP from Wind River, version 6.9/1 Altera SoC EDS, version 14.0 Altera Quartus Programmer, version 14.0 Ubuntu 12.04 LTS, running as a virtual machine on Windows using Oracle’s® VirtualBox® 4.2.6 with VBoxGuestAdditions installed to share files between Windows and Linux The mkimage binary and all of the preloader binaries are built from GPL licensed open source software included with Altera’s SoC EDS product. This product and the source can be downloaded for free from the Altera Software Depot download page.\nRelated Information\nWin32 Disk Imager Altera Software Depot website Instructions on booting VxWorks # In order to boot VxWorks, you can use these instructions to build a bootable system using a preloader and u-boot, and then replace the u-boot bootloader with a VxWorks bootrom.\nFor SD/MMC boot: You can use the pre-built SD/MMC images to create a bootable system using u-boot in place of the VxWorks bootrom to see your board boot. You can then replace the provided u-boot bootloader with a VxWorks bootrom and see VxWorks boot using the same SD card. For QSPI boot: You can use the provided SD/MMC images to boot u-boot, then use u-boot to program the binaries into QSPI. You can then boot from QSPI. Note: Optionally, you can program QSPI binaries using the Altera Quartus programmer. This method does not require SD/MMC but does require a USB Blaster connection and the free Altera programmer. What is New for 14.0 # The preloader has a new feature that allows you to program the FPGA. These instructions contain SD images with a preloader that programs the FPGA on boot from a FAT partition on the SD card. This makes FPGA programming much easier.\nNote: All preloaders and bootloaders are updated so that they can be built with the Altera 14.0 tools. Configuring the Altera Cyclone V Development Board # Set up the board as shown in the Factory Default Switch and Jumper Settings section located in chapter 3: Development Board Setup, in the Cyclone V SoC Development Kit User Guide.\nIn particular, ensure that SW2 and SW3 are set correctly, they are important to FPGA programming.\nIf you position the development board so that you can read the \u0026ldquo;ALTERA\u0026rdquo; logo on the board, SW2 should have the settings right-right-left-right, reading from the top. If you plan to program the FPGA, SW3 (MSEL) should have all switches set to the positions up-down- up-down-up-up, reading from left to right. Note: These MSEL switch positions are related to how the FPGA is built, either with or without compres‐ sion and in a particular format. Related Information\n*Factory Default Switch and Jumper Settings\nHow the Boot Process Works # The Altera SoC product goes through different boot stages, shown below:\nFigure 1: VxWorks Boot Flow The BootROM is hard coded into the chip and cannot be changed. Upon boot, the BootROM loads the preloader into on-chip RAM, and hands control to it after loading. This BootROM is not the same as the VxWorks BootROM, which is often refered to in the Wind River documentation as \u0026ldquo;bootrom\u0026rdquo;.\nThe second phase of the boot process is the preloader. The preloader completes the initial boot sequence, by setting up the clocks, the external RAM, and the pin configuration of the Altera SoC device. The preloader finishes initial configuration and then loads the VxWorks bootrom into external RAM. It then hands control to the VxWorks bootrom or some other bootloader like u-boot. The preloader can also program the FPGA.\nThe VxWorks bootrom then loads the VxWorks application into external RAM, and hands control of the system to the final application.\nAbout the VxWorks BootROM and Preloader # Both the preloader and the VxWorks bootrom can be built from source and must include a header portion that allows the previous boot stage to validate each boot stage. This package contains prebuilt versions of the preloader for the Cyclone V and Arria V SoC development boards that were built using Altera’s SoC EDS environment.\nThe preloader is typically built by the FPGA designer. This person determines the correct PIN configura‐ tion using Altera’s Quartus and Qsys tools, designs the FPGA portion of the system, and generates the preloader using the preloader Generator, which is part of Altera’s SoC EDS tools.\nThe VxWorks bootrom is built by a software engineer using Wind River\u0026rsquo;s development tools. This engineer configures the VxWorks BootROM and builds it in Wind River’s tool, then uses mkimage from Altera\u0026rsquo;s SoC EDS to put the proper header on the bootrom. For the Cyclone V and Arria V boards, the preloader is board specific and the VxWorks BootROM is not.\nThe preloader and bootrom are then combined into an SD/MMC image or programmed into QSPI to boot the system.\nThe Altera SoC EDS tool includes a pre-configured preloader that works with Altera’s development board. Custom boards may require their own preloader configured for their board.\nSuggested Ways to Build the VxWorks BootROM # There are two standard ways of building the VxWorks BootROM:\nUse the Command Line BootROM Build a BootROM from a VxWorks Image Project (VIP) Use the Command Line BootROM # Build the default bootrom from the BSP.\nOpen a VxWorks 6.9 Development Shell from within Workbench. In the shell, change to the Wind River install directory. Entercd vxworks_6.9/target/config/alt_soc_gen5 at the prompt. Build the default bootrom by entering: make bootrom.bin. For this method, the starting address used with mkimage should be something other than the starting address of the binary. This bootrom uncompresses itself to RAM, so it is best to load it somewhere else in memory so that it can be uncompressed to the starting address. For our testing, we used the value 0x08000040 with mkimage.\nBuild a BootROM from a VxWorks Image Project # Create a VxWorks Image Project and build it.\nCreate a VxWorks Image Project with the profile PROFILE_BOOTAPP. Set the build spec to default_rom. Build the vxworks.bin target in the project. Use the vxWorks_rom.bin file in the default_rom build directory in the project. For this method, the starting address used with mkimage should be the address shown when you run objdump -f on the vxworks_rom file in the same directory. For our testing, this value is 0x3f000000.\nBoth of these binaries still need to be wrapped using the mkimage program described in the following sections before they can be used with the preloader.\nBoth of these binaries properly initialize RAM with boot values so that you can change boot parameters and then use them to start vxWorks.\nCustom Preloader Settings Used for VxWorks # These instructions contain preloaders built from Altera’s SoC EDS tool, version 14.0. You do not have to build the preloader if you plan to use the included binaries, but the source to the preloader and the mkimage program are included in the SoC EDS.\nThe sofware can be downloaded from the Altera Software Depot webpage using the free web edition.\nYou can select and download just the SoC EDS. If you plan to program QSPI using the USB Blaster connection on the development board, you may wish to also install the Quartus II Programmer and SignalTap II software.\nThe pre-built preloaders included in this package work with the Altera development boards. Other boards may require starting with an FPGA design, as described in the HPS Preloader User Guide section of the Altera SoC Embedded Design Suite User Guide.\nOn Windows, you can get to the preloader code through a windows command shell by starting an Altera command shell from: Start \u0026gt; All Programs \u0026gt; Altera \u0026lt;version\u0026gt; \u0026gt; SoCEmbedded Design Suite (EDS) \u0026lt;version\u0026gt; \u0026gt; SoCEDS 14.0 Command Shell.\nThis will start a shell with two important variables:\nQUARTUS_ROOTDIR='C:\\altera\\14.0\\qprogrammer' SOCEDS_DEST_ROOT=C:/altera/14.0/embedded The preloader is located at $SOCEDS_DEST_ROOT/examples/hardware/cv_soc_devkit_ghrd/software/preloader/.\nNote: Several changes were made to the standard preloader configuration to create the included binaries. Related Information\nAltera Software Depot website Altera SoC Embedded Design Suite User Guide Preloader Changes Made for SD/MMC # The SD/MMC boot contains two preloader changes. The first change modified the preloader to load the bootloader from the FAT partition of the SD/MMC card rather than the RAW partition. This allows you to store your VxWorks bootrom on the FAT partition. In the second change, the name of the file that is loaded by the preloader is no longer set to u-boot by default. This file name needs to be the name of the VxWorks bootrom, wrapped by mkimage.\nThe modifications made to the uboot-socfpga/board/altera/socfpga/build.h file are shown below in bolded text:\n/* Enable FAT partition support when booting from SDMMC. */ #define CONFIG_PRELOADER_FAT_SUPPORT (1) /* * When FAT partition support is enabled, this specifies the * FAT partition where the boot image is located. */ #define CONFIG_PRELOADER_FAT_BOOT_PARTITION (1) /* * When FAT partition supported is enabled, this specifies the * boot image filename within a FAT partition to be used as * fatload payload. */ #define CONFIG_PRELOADER_FAT_LOAD_PAYLOAD_NAME \u0026#34;bootloader.bin\u0026#34; Another change where the preloader loads the FPGA file was made to the uboot-socfpga/include/configs/socfpga_common.h file.\n/* * FPGA programming support with SPL * FPGA RBF file source (with mkimage header) is located within the same * boot device which stored the subsequent boot image (U-Boot). */ /* enabled program the FPGA */ #define CONFIG_SPL_FPGA_LOAD Preloader Changes Made for QSPI # The QSPI boot contains one preloader change. This change made modifications to the preloader to load the VxWorks bootrom from QSPI rather than from the SD/MMC. In another change, the preloader now loads the FPGA. With this change, the preloader now programs the FPGA from a known QSPI address during boot.\nThe modifications made to the uboot-socfpga/board/altera/socfpga/build.h file are shown below in bolded text:\n/* * Boot option. 1 means that particular boot mode is selected. * Only 1 boot option to be enabled at any time */ #define CONFIG_PRELOADER_BOOT_FROM_QSPI\t(1) #define CONFIG_PRELOADER_BOOT_FROM_SDMMC (0) /*#define CONFIG_PRELOADER_BOOT_FROM_NAND (0)*/ #define CONFIG_PRELOADER_BOOT_FROM_RAM\t(0) Another change where the preloader loads the FPGA file is shown in the uboot-socfpga/include/configs/socfpga_common.h file in bolded text:\n/* * FPGA programming support with SPL * FPGA RBF file source (with mkimage header) is located within the same * boot device which stored the subsequent boot image (U-Boot). */ /* enabled program the FPGA */ #define CONFIG_SPL_FPGA_LOAD /* location of FPGA RBF image within QSPI */ #define CONFIG_SPL_FPGA_QSPI_ADDR (0x800000) Note: The last line of the code above sets the address in QSPI to program the FPGA binary file. In this example, the default value is used. Creating a Bootable Environment Using SD/MMC # Set up the board for SD/MMC boot. With the Altera Cyclone V SoC board oriented so that you can read the Altera Cyclone V SoC logo, set the following jumpers:\nSet jumper BootSEL0: Closed to the right: .[..] Set jumper BootSEL1: Closed to the right: .[..] Set jumper BootSEL2: Closed to the left: [..]. The sequence for boot selects 0..2 should look like: .[..] .[..] [..].\nCreate an SD/MMC card. Unzip the provided binary file for your development board and use the Win32 Disk Imager program to write it to an SD card. Start from the correct image for your development board:\nsdmmc/av_140_fat_sdmmc.zip for Arria V sdmmc/cv_140_fat_sdmmc.zip for Cyclone V Load the card into your development board and power up. Connect a USB cable between the serial port on the Altera development board and a USB port on your Windows computer. Verify that you see a COM port on your Windows computer. Apply power to the development board and connect to the COM port at a baud rate of 115200. Verify that you see the COM port in the Devices and Printers control panel on your Windows computer. You should see the output of the preloader, followed by the output of u-boot. This verifies that you can boot your board with the pre-built image and see serial output. The pre-built images include a copy of u-boot that has been renamed to bootloader.bin as a stand-in for your VxWorks bootrom. Build the VxWorks Bootrom. Build your VxWorks bootrom file using Wind River tools and the `alt_soc_gen5` BSP. You can build a command line bootrom, or build a bootrom from a VxWorks Image Project.\nFor more information on how to build a VxWorks bootrom, contact Wind River or read the BSP documentation.\nAdd the Altera header to the VxWorks Bootrom. Use mkimage to wrap the VxWorks bootrom file with the proper header image. A Windows binary for this tool is included in this package. The mkimage tool is available for linux, as well, but is not included in this package.\nThis header image contains the address that the preloader uses to load the bootrom. The value 0x08000040 is a good default choice for the compressed bootrom built from the command line. This bootrom will relocate itself to a different area of RAM. Other bootroms may have a different starting address. You can discover the starting address for an ELF version of a bootrom by using this command from a VxWorks development shell:\nobjdumparm –f \u0026lt;yourfilename\u0026gt; For Windows, use the mkimage program, as shown in the following command, for the default bootrom.bin file:\nmkimage.exe -A arm -T firmware -C none -O vxworks -a 0x08000040 - e 0 -n \u0026#34;vxWorks bootloader for SoC FPGA\u0026#34; -d bootrom.bin bootloader.bin In the other files, use an appropriate starting address for the -a option, as determined from the objdumparm command. The mkimage command is similar for Linux, but without the .exe extension.\nPut the VxWorks bootrom on the FAT partition. Power off the board, remove the SD/MMC card from the board and put it back in your PC. On Windows, you should see a new removable drive appear. Copy the file bootloader.bin created in the previous step to the SD/MMC card, eject the card from the PC, and insert it into the development board. Boot the board with the VxWorks Bootrom. Turn on the development board while monitoring the serial port. You should see the preloader boot first, followed by the VxWorks bootrom. You can stop the VxWorks bootrom to change the boot parameters, or allow it to continue to boot. Related Information\nWind River Board Support Packages\nCreating a Bootable Environment for QSPI Using the SD/MMC Card # First, create a bootable SD/MMC image with u-boot and then use the u-boot to program the VxWorks bootrom into QSPI. This avoids the use of the Altera Quartus programmer, but requires an SD/MMC card instead.\nPerform step 1 - 5 of the Creating a Bootable Environment Using SD/MMC method. Rename and copy the VxWorks bootrom to the SD/MMC card. On your host system, rename your bootloader.bin file to vxworksqspi.bin, so that it will not be confused with the bootrom on the SD/MMC card. Power off the board and remove the SD/MMC card from the board and put it back in the PC. On Windows, you should see a new removable drive appear. Copy the file vxworksqspi.bin to the SD/MMC card. Locate the pre-built QSPI specific preloader binary for your development board. This file is included in this package at: qspi/cv/preloader-mkpimage.bin For Cyclone V qspi/av/preloader-mkpimage.bin For Arria V Copy your vxworksqspi.bin file and the appropriate preloader-mkpimage.bin file to the SD/MMC card. Eject the card from the PC and insert it into the development board. Copy the FPGA binary to the SD/MMC card. The SD FAT partition already includes the correct fpga.rbf file, but it is also included in the instruc‐ tions at:\nghrd_fpga/cv/fpga.rbf For Cyclone V ghrd_fpga/av/fpga.rbf For Arria V You must convert this file using mkimage for use with QSPI. This is not required when the file is on the SD/MMC FAT partition. In order to do this, you must copy the fpga.rbf file to a directory and run this mkimage command:\nmkimage -A arm -T firmware -C none -O u-boot -a 0 -e 0 -n \u0026#34;FPGA\u0026#34; – d fpga.rbf fpga.img When done, copy the fpga.img file to the FAT partition on the SD card.\nUse u-boot to program QSPI. Turn on the development board and make sure the u-boot booted. The board boots up to a u-boot prompt and stops. Your QSPI preloader and VxWorks bootrom are now on the FAT partition of the SD/MMC card. Load the preloader file from the SD/MMC card into a temporary RAM location. Partially erase the QSPI flash and program the preloader into QSPI: % fatload mmc 0:1 0x2000000 preloader-mkpimage.bin % sf probe % sf erase 0x0 0x40000 % sf write 0x2000000 0x0 $filesize Load the VxWorks bootrom file from the SD/MMC card into a temporary RAM location. Partially erase the QSPI flash and program the bootrom into QSPI. You must erase on 64K boundaries (rounding up to the boundary past your file size): % fatload mmc 0:1 0x2000000 vxworksqspi.bin % printenv filesize Note: If the filesize is on a 64K boundary, like 0x40000, you can use that number for the erase command in the next sequence. If not, you must erase up to the next 64K boundary.\nFor example, if the file size is 0x5a360, you must use the value 0x60000 as the last argument to the erase command. Use this value for \u0026lt;your-erase-value\u0026gt; in the commands below:\n% sf probe % sf erase 0x60000 \u0026lt;your-erase-value\u0026gt; % sf write 0x2000000 0x60000 $filesize Load the FPGA binary from the SD/MMC card into a temporary RAM location. Partially erase the QSPI flash and program the FPGA into QSPI. You must erase on 64K boundaries (rounding up to the boundary beyond your file size): % fatload mmc 0:1 0x2000000 fpga.img % printenv filesize Note: Like the last example, you must erase up to the next 64K boundary. For example, if the filesize is 0x5a360, you must use the value 0x60000 as the last argument to the erase command. Use this value for \u0026lt;your-erase-value\u0026gt; in the commands below:\n% sf probe % sf erase 0x800000 \u0026lt;your-erase-value\u0026gt; % sf write 0x2000000 0x800000 $filesize In the above examples, 0x2000000 is a random RAM location, and can be replaced with any other RAM location that is not in use. The value 0x800000 is the starting address in QSPI for the FPGA image.\nTurn off the development board and remove the SD/MMC card. It is OK to leave the card in if you wish, but removing it verifies that you are no longer booting from SD/MMC.\nWith the Altera Cyclone V SoC board oriented so that you can read the \u0026ldquo;Altera Cyclone V SoC\u0026rdquo; logo, set the following jumpers for QSPI boot:\nSet jumper BootSEL0: Closed to the right: .[..] Set jumper BootSEL1: Closed to the left: [..]. Set jumper BootSEL2: Closed to the left: [..].\nThe entire sequence for boot selects 0..2 should look like: .[..] [..]. [..].\nBootup, monitoring the serial port to see if it worked. Turn on the development board while monitoring the serial port or connect to it quickly after power- up if the terminal emulator does not allow connecting before power-up. You should see the output of the preloader, followed quickly by the output of the VxWorks bootrom. If you miss these messages, then press the warm reset button to reboot.\nCreating a QSPI Bootable Environment with the Quartus Programmer # If you choose not to create an SD/MMC card, first, in order to boot QSPI, then the Altera quartus_hps programmer can be used with the USB blaster connector to load the preloader and VxWorks bootrom into the QSPI.\nFor this method, the QSPI preloader from this package and the VxWorks bootrom you created in the previous section are needed. Also the fpga.img file created from the fpga.rbf file in the previous section is needed.\nCollect the files that are needed. Follow the steps from the Creating a Bootable Environment for QSPI Using the SD/MMC Card section to:\nCreate a VxWorks bootrom. Wrap the bootrom using the mkimage program. Get the correct fpga.rbf file for your board (Cyclone V or Arria V). Wrap the fpga.rbf file using the mkimage program to create the fpga.img. Get the correct QSPI preloader for your board (Cyclone V or Arria V). After these steps you should have these files:\nFile Description preloader-mkpimage.bin The QSPI preloader from this package for your board. fpga.img The fpga.rbf from this package, wrapped with mkimage. vxworksqspi.bin The VxWorks bootrom you built, wrapped with mkimage. Set up the board for QSPI boot. With the Altera Cyclone V SoC board oriented so that you can read the “Altera Cyclone V SoC” logo, set the following jumpers for QSPI boot:\nSet jumper BootSEL0: Closed to the right: .[..] Set jumper BootSEL1: Closed to the left: [..]. Set jumper BootSEL2: Closed to the left: [..]. The entire sequence for boot selects 0..2 should look like: .[..] [..]. [..].\nGet Altera's Quartus II Programmer tool. For more information on how to download and install version 14.0 of Altera’s Quartus Programmer tool, navigate to the Quartus II Programmer and SignalTap II install under the Additional Software tab on Altera\u0026rsquo;s Software Depot website.\nOn Windows, create an embedded command shell. Start an Altera command shell from Start \u0026gt; All Programs \u0026gt; Altera \u0026lt;version\u0026gt; \u0026gt; SoC Embedded Design Suite (EDS) \u0026lt;version\u0026gt; \u0026gt; SoC EDS 14.0 Command Shell.\nThis will start a shell with two important variables:\nQUARTUS_ROOTDIR=\u0026#39;C:\\altera\\14.0\\qprogrammer\u0026#39; SOCEDS_DEST_ROOT=C:/altera/14.0/embedded Connect a USB cable to the USB blaster port. Connect a USB cable from a USB port on your Windows PC to the port labeled \u0026ldquo;USB Blaster\u0026rdquo; on the board to be programmed.\nDiscover your JTAG cable name. From your embedded command shell, power on your board and run the jtagconfig command.\n1) USB-BlasterII [USB-1] 4BA00477 SOCVHPS 02D020DD 5CS(EBA6ES|XFC6C6ES)/.. 020A40DD 5M(1270ZF324|2210Z)/EPM2210 In this example, the cable is 1. Use this value for all calls to quartus_hps as the parameter .\nProgram the preloader, VxWorks bootrom and FPGA image into QSPI. Program the preloader file into QSPI: quartus_hps -c \u0026lt;cable\u0026gt; -o P -a 0 -s 0x40000 preloader-mkpimage.bin Program the VxWorks bootrom into QSPI at address 0x60000. This address is from the preloader build.h file in the define CONFIG_PRELOADER_QSPI_NEXT_BOOT_IMAGE:\nquartus_hps -c \u0026lt;cable\u0026gt; -o P -a 0x60000 vxworksqspi.bin Program the FPGA image file into QSPI at address 0x800000. This address is from the preloader socfpga_common.h file in the define CONFIG_SPL_FPGA_QSPI_ADDR:\nquartus_hps -c \u0026lt;cable\u0026gt; -o P -a 0x800000 fpga.img Boot up, monitoring the serial port to see if it worked. After programming these files, it is important to remove power from the board for about ten seconds. The user may see a CRC error upon load if the board is not powered down for enough time. This can be resolved by removing power, waiting, and trying again.\nTurn on the development board while monitoring the serial port at 115200 baud. You should see the output of the preloader, followed by the output of the VxWorks bootrom.\nRelated Information\nAltera\u0026rsquo;s Software Depot website Configuring VxWorks using the Bootloader # From the VxWorks bootlooader, you can use the p command to print the boot settings and the c command to change them. The M command can be used to change the MAC address of the emac1 port.\nConfiguring for Boot with the VxWorks Image on an FTP Server # Use the following boot parameters:\nTable 1: Boot Parameters\nParameter Value boot device emac1 unit number 1 processor number 0 host name host file name C:/WindRiver/vxworks-6.9/target/config/alt_soc_gen5/vxWorks inet on ethernet (e) 192.168.1.2:ffffff00 host inet (h) 192.168.1.20 gateway inet (g) 192.168.1.1 user (u) target ftp password (pw) vxTarget flags (f) 0x0 target name (tn) alt_soc_gen5 other (o) - For Ethernet boot, the \u0026ldquo;inet on Ethernet\u0026rdquo; address should be a static IP address assigned to the board. The hex code after the address is a network mask. The \u0026ldquo;host inet\u0026rdquo; address is the address of the machine with the VxWorks application.\nMost developers use Ethernet boot when developing code, then copy their code to the SD card for booting without using a host.\nConfiguring for Boot with the VxWorks Image on the SD Card FAT Partition # VxWorks can also be booted from the FAT partition on the SD/MMC card. To do so, edit the config.h file in the BSP directory to add the following options:\n/* Add this to end of config.h to boot vxworks from the SD flash file system */ #define DRV_STORAGE_ALT_SOC_GEN5_DW_MSHC #define INCLUDE_BOOT_FILESYSTEMS #define INCLUDE_DOSFS Next:\nBuild bootrom.bin from a VxWorks development shell. Use mkimage.exe to create the bootloader.bin file as described in Step 5 of the Creating a Bootable Environment Using SD/MMC section. Copy the bootloader.bin and your VxWorks image to the FAT partition of your SD card. Use the following boot parameters listed in the following table:\nTable 2: Boot Parameters\nParameter Value boot device fs unit number 0 processor number 0 host name host file name /sd0:1/vxWorks inet on ethernet (e) 192.168.1.2:ffffff00 host inet (h) 192.168.1.20 gateway inet (g) 192.168.1.1 user (u) target ftp password (pw) vxTarget flags (f) 0x0 target name (tn) alt_soc_gen5 other (o) emac1 Optionally, specifying \u0026ldquo;emac1\u0026rdquo; in the other field, will configure and enable the Ethernet port even though it is not actually booting over Ethernet. The VxWorks BSP target.ref file has more information on SD support.\nThis boot method cannot be used in conjunction with the boot method in the following DHCP section.\nConfiguring for Boot Using DHCP and FTP # VxWorks can also use DHCP to get an IP address before retrieving the VxWorks image via FTP. To do so, edit the config.h file in the BSP directory to add the following options:\n/* Add this to end of config.h to boot vxworks using DHCP */ #define INCLUDE_BOOT_DHCPC #define INCLUDE_IPDHCPC #define DHCPC_OPTION_MAX_MESSAGE_SIZE \u0026#34;576\u0026#34; #define DHCPC_TTL \u0026#34;1\u0026#34; #define DHCPC_FLAGS_BIT_BROADCAST \u0026#34;0\u0026#34; #define DHCPC_IF_INFORMATION_ONLY_LIST \u0026#34;\u0026#34; #define INCLUDE_IPNET_IFCONFIG_1 #define IFCONFIG_1 \\ \u0026#34;ifname\u0026#34;,\u0026#34;devname driver\u0026#34;,\u0026#34;inet dhcp\u0026#34;,\u0026#34;gateway dhcp\u0026#34;,\u0026#34;inet6 3ffe:1:2:3::4/64\u0026#34; Next:\nBuild bootrom.bin from a VxWorks development shell. Use mkimage.exe to create the bootloader.bin file as described in Step 5 in the Creating a Bootable Environment Using SD/MMC section. Copy the bootloader.bin and your VxWorks image to the FAT partition of your SD card. Uset the following boot parameters:\nTable 3: Boot Parameters\nParameter Value boot device emac1 unit number 1 processor number 0 host name host file name C:/WindRiver/vxworks-6.9/target/config/alt_soc_gen5/vxWorks inet on ethernet (e) - host inet (h) 192.168.1.20 gateway inet (g) 192.168.1.1 user (u) target ftp password (pw) vxTarget flags (f) 0x40 target name (tn) alt_soc_gen5 other (o) - This boot method cannot be used in conjunction wit the boot method in the previous SD section.\nSample Images # This package comes with prebuilt images that have been tested with the development boards.\nThe ghrd_fpga directory contains FPGA binaries for the Altera Golden Hardware Reference Design:\nav - contains the GHRD binary for the Arria V SoC product cv - contains the GHRD binary for the Cyclone V SoC product The qspi and sdmmc directories each contain subdirectories for each target board:\nav - support for the Arria V SoC development board cv - support for the Cyclone V SoC development board Each of the av and cv directories contains preloader (spl) code specific to qspi or sdmmc:\nu-boot-spl - an ELF version of the preloader that can be used with DS-5 Altera Edition u-boot-spl.bin - the preloader u-boot-spl.map - a map file for the preloader preloader-mkpimage.bin - the four-copy preloader with the proper header image The sdmmc directory additionally contains these files:\nmake_sdimage.sh - a Linux script for creating SD/MMC images av_140_fat_sdmmc.zip - a prebuilt SD/MMC image for the Arria V board cv_140_fat_sdmmc.zip - a prebuild SD/MMC image for the Cyclone V board The sample SD/MMC images were created on a Linux system, running as root, using the following command:\n./make_sdimage.sh -p preloader-mkpimage.bin -b u-boot.img –k bootloader.bin,u-boot.img,fpga.rbf,readme.txt –o cv_140_fat_sdmmc.img -g 512M The preloader and FPGA files were built specifically for the development board and are different between Cyclone V and Arria V. The u-boot.img file included on the RAW partition is not used and is just there to satisfy the make_sdimage.sh script. The preloader is configured to boot the file bootloader.bin on the FAT partition. For SD/MMC, the preloader loads the fpga.rbf file from the FAT partition on the SD card. The SD card images include a version of u-boot that can be used to program the QSPI.\nOther Resources # For more Altera documentation, you can visit the Altera SoC Embedded Software Tools documentation page and the Altera SoC Embedded Design Suite User Guide.\nFor more information on using Linux with the Altera SoC or how to set up the development board, refer to the Rocketboards website.\nRelated Information\nAltera SoC Embedded Software Tools Altera SoC Embedded Design Suite User Guide Rocketboards ","date":"2024-10-07","externalUrl":null,"permalink":"/bsp/booting-vxworks-with-altera-cyclone-v/","section":"Board Support Package","summary":"\u003ch2 class=\"relative group\"\u003ePurpose of this Article \n    \u003cdiv id=\"purpose-of-this-article\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#purpose-of-this-article\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003eThis article describes how to take a VxWorks® bootrom that is built using the Wind River® BSP, alt_soc_gen5, combine it with a preloader built from an Altera® FPGA design, and boot the Altera Cyclone® V and Arria® V SoC development boards using QSPI or SD/MMC.\u003c/p\u003e","title":"Boot VxWorks With Altera Cyclone V","type":"bsp"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/series/bsp/","section":"Series","summary":"","title":"BSP","type":"series"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/tags/cyclone-v/","section":"Tags","summary":"","title":"Cyclone V","type":"tags"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"","date":"2024-10-07","externalUrl":null,"permalink":"/tags/vxworks-6.9/","section":"Tags","summary":"","title":"VxWorks 6.9","type":"tags"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/tornado/","section":"Tags","summary":"","title":"Tornado","type":"tags"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/vxworks-5.4/","section":"Tags","summary":"","title":"VxWorks 5.4","type":"tags"},{"content":" Preface # This guide is for device driver developers, who have general background in real time operating systems. This guide addresses device driver development using VxWorks 5.4/Tornado 2.0.\nWe referred to VxWorks 5.4 programmers manual and other VxWorks website to make sure the content is as accurate as possible.\nReal Time Operating System and VxWorks # Operating systems can be categorized into real-time and non-real-time systems. A real-time system is defined as a system where the response time for an event is predictable and deterministic with minimal latency. The architecture of the operating system\u0026rsquo;s scheduler, also referred to as the dispatcher, has a significant impact on the responsiveness of the OS. Preemptive scheduling ensures the highest priority task/thread always runs and doesn’t relinquish the CPU until its work is done or a higher priority task becomes available. A preemptive scheduler also implies a real-time kernel. Several aspects to consider when selecting a real-time OS are:\nFoot print of the kernel Interrupt latency Interrupt response time Interrupt recovery Multi-tasking Task context switching Virtual memory support VxWorks provides a real-time kernel that interleaves the execution of multiple tasks employing a scheduling algorithm. Thus the user sees multiple tasks executing simultaneously. VxWorks uses a single common address space for all tasks thus avoiding virtual-to-physical memory mapping. Complete virtual memory support is available with the optional vxMem library.\nTour of VxWorks # Tasks # A task is an independent program with its own thread of execution and execution context. Every task contains a structure called the task control block that is responsible for managing the task\u0026rsquo;s context. A task\u0026rsquo;s context includes\nprogram counter or thread of execution CPU registers Stack of dynamic variables and function calls Signal handlers IO assignments Kernel control structures Every task has a name and an ID associated with it. Each task is assigned a default priority as well. A task has four states as shown below.\nA task can be created with taskInit() and then activated with taskActivate() routine or both these actions can be performed in a single step using taskSpawn(). Once a task is created it is set to the suspend state and suspended until it is activated, after which it is added to the ready queue to be picked up by the scheduler and run. A task may be suspended by either the debugging your task, or the occurrence an exception. The difference between the pend and suspend states is that a task pends when it is waiting for a resource. A task that is put to sleep is added to delay queue.\nScheduler # VxWorks scheduler determines which task to own the CPU time. By default, the scheduler runs a preemptive algorithm. Preemptive scheduler guarantees that the highest priority task preempts a lower priority task. There are some special cases called priority inversion which is discussed in advanced concepts.\nThe scheduler can be set to run round robin algorithm which is a time slicing algorithm.\nMutual Exclusion # Mutual exclusion can be implemented in VxWorks in the following three ways.\nSemaphores Disabling Interrupts Disabling the scheduler using taskLock() Semaphores # VxWorks supports three types of semaphores, binary, mutual exclusion, and counting, each of which is optimized for a specific application. Semaphores are generally used for task synchronization and communication, and protection of shared resources also referred to as concurrency control or mutual exclusion.\nBinary semaphores are the fastest and are best suited for basic task synchronization and communication. Mutual exclusion semaphores are sophisticated binary semaphores that are designed to address the issues relating to task priority inversion and semaphore deletion in a multitasking environment. Counting semaphores maintain a count of the number of times a resource is given. This is useful when an action is required for each event occurrence. For example if you have ten buffers, and multiple tasks can grab and release the buffers, then you want to limit the access to this buffer pool using a counting semaphore. Message Queues # VxWorks supports messages queues for inter task communication. A variable number of messages, each of variable length, can be sent to any task. ISRs and tasks can send messages but only tasks can receive messages.\nMultiple tasks can wait on a single message queue and can be ordered by their priority. Messages can be marked urgent for faster delivery.\nNetwork Intertask Communication # VxWorks supports general facilities like pipes, sockets, RPC and signals for network inter task communications.\nAdditional Facilities # VxWorks provides facilities like Asynchronous IO and buffered IO for application and driver development. It is also POSIX library.\nInterrupts and Interrupt handling # Interrupt is the mechanism by which a device seeks the attention of CPU. The piece of user code that the CPU executes on interrupt is called interrupt service routine (ISR). The Kernel doesn\u0026rsquo;t transfer execution to the ISR immediately. It does some house keeping before the ISR is executed. The delay between the occurrence of interrupt and time spent by the kernel before it executes the first ISR instruction is called Interrupt response time. This equals the sum of interrupt latency and time to save CPU\u0026rsquo;s context and execution time of kernel ISR entry function.\nVxWorks provides a special context for interrupt service code to avoid task context switching, and thus renders fast response. VxWorks supplies interrupt routines which connect to C functions and pass arguments to the functions to be executed at interrupt level. To return from an interrupt, the connected function simply returns. A routine connected to an interrupt in this way is referred to as an interrupt service routine (ISR) or interrupt handler. When an interrupt occurs, the registers are saved, a stack for the arguments to be passed is set up, then the C function is called. On return from the ISR, stack and registers are restored.\nIntConnect(INUM_TO_IVEC(intNum), intHandler, argToHandler) allows C functions to be connected to any interrupt. The first argument to this routine is the byte offset of the interrupt vector to connect to. The second argument is the interrupt handler and the last is any argument to this handler.\nOne can disable interrupts using intLock() for synchronization. Care should be taken to re-enable the interrupts using intUnlock(). If you are planning for nested interrupts, you should not disable interrupts using intLock(). Also make sure that your code is reentrant and you allocate enough stack resources for nesting.\nPoints to remember Within an ISR, limited capabilities exist for the user code. Not all library functions are available. Since memory facilities malloc() and free() take semaphores, they cannot be called within ISR. Any blocking call is to be avoided. Semaphores can be given, but not taken from an ISR. Points to remember ISR can communicate with user tasks via\nshared memory and ring buffers release of semaphores signal tasks writing to pipes sending messages using message queue Understanding ISR and what goes on within interrupt handler is the key to designing your driver. Many real world drivers just have an interrupt handler and interact with user and device without the rest of the interfaces. Please refer to 7) for examples.\nDevices and Drivers # A driver supplies a uniform device independent logical interface to the user to interact with a device. A device can be a piece of hardware such as your hard drive or can be a piece of software such as a pipe or a socket, but a driver is always a software module. A driver can control multiple devices. If the architecture allows virtual memory, driver works in a logical/virtual address space, but a device works in a physical address space.\nAll interactions with devices in VxWorks are performed through the IO sub-system. VxWorks treats all devices as files. Devices are opened just like normal files are for IO operations. An example device is /tyCo/0 that represents a serial channel. When a filename is specified in an IO call by the user task, the IO system searches for a device with a name that matches the specified filename. Two most important devices are character devices or non-block and block devices. Character devices perform IO operations character by character. Block devices are used for storing file systems. Block devices perform IO in blocks of characters and can support complicated operations such as random access. Block devices are accessed via file system routines as shown in the above figure. The driver interface to character devices are not filesystem routines.\nPoints to remember A character device is named usually at the system initialization Block devices are always associated with a file system like raw file system, dos file system. They are named when initialized for a specific file system. Drivers can be loaded and unloaded dynamically. Drivers work in thee context of the task invoked an interface routine. Hence drivers are preemptable and should be designed as such. Character Drivers # creat(), remove(), open(), close(), read(), write(), ioctl() are the seven standard driver interfaces that can be exposed to the user. Not all of the interfaces are mandatory.\nFour steps are involved in the driver design and install process.\nStep 1: Decide the interfaces you want to expose and install the driver The following piece of code is the driver initialization routine.\nSTATUS myDrv() { myDrvNum = iosDrvInstall(myDevCreate /* create */ , 0 /* remove() is null */ , myDevOpen /* open() */ , 0 /* close() */ , myDevRead /* read() */ , myDevWrite /* write() */ , myDevIoctl /* ioctl() */ ); /* connect the ISR */ intConnect(intvec, myIntHandler, 0); } As shown in the above piece of code, we can skip the driver interface routines like remove and close. But it is always a good practice to include them and return an error. VxWorks returns an error on your behalf, if it doesn\u0026rsquo;t find a particular interface. Also you can initialize any relevant data structures in the myDrv routine.\nPoints to remember myDrvNum is used by the IO subsystem in locating your device. The device driver gets installed into a driver table. The index is based on driver number. Since a driver can service more then one device, a list of devices are tied together in a linked list, with the same driver number, but different device names and device descriptors. Step 2: Create your device descriptor structure Capture the essence of your device in a structure. This structure will hold all the information related to your device. This structure will be passed back by the IO subsystem, as a parameter to the rest of the interfaces like read(), write(), ioctl() etc., You can even get this structure within your ISR.\ntypedef struct { DEV_HDR myDevHdr; BOOL isDevAvailable; Semaphore getAccess; } MY_DEV; If you are using semaphores to control the access to your device, make sure you create and initialize them before you make use of them.\nOnce you are ready with your structure, pass it as an address to iosDevAdd as shown in the below piece of code.\nSTATUS myDevCreate(char *name, …) { MY_DEV *pMyDevice; status = iosDevAdd(pMyDevice, /* pointer to MY_DEV device */ name, /* input param */ myDrvNum /* return value from iosDrvInstall */ ); /* do other work as necessary */ } iosDevAdd takes three arguments. The first argument is the address of device descriptor structure. A device descriptor structure always starts with DEV_HDR structure as it\u0026rsquo;s first member. It can contain any other private data structures for your own use. The second argument is the name of the device. The third argument is the driver number, the return value of iosDrvInstall.\nPoints to remember IO subsystem searches the correct device based on device name and driver number. They are held in a header structure DEV_HDR.\nStep 3: Finish the definitions of all other interfaces STATUS myDevOpen(MY_DEV * pMyDev, char *additionalInfo, int mode) { } STATUS myDevRead(MY_DEV * pMyDev, char *buffer, int nBytes) { /* read nBytes from the device and put them into the buffer*/ } STATUS myDevWrite(MY_DEV * pMyDev, char *buffer, int nBytes) { /* write to the device from buffer if the device has room*/ } IOCTL needs some explanation. It is through IOCTL that a user can control the device. This the preferred way of controlling the device. The code within the IOCTL depends upon the way your device perform and the way you want to control the device.\nSTATUS myDevIoctl(MY_DEV * pMyDev, int request, int arg) { switch (request) { CASE SET_DEVICE: /* set the device */ CASE MODIFY_PARAM: } } Step 4: Complete your interrupt handler Void myIntHandler(arg) { /* disable any further interrupts */ intLock(); // now read the interrupt register and indicate to the other tasks that you received an interrupt. // You can do this in multiple ways. Refer to \u0026#39;Tour of VxWorks\u0026#39; // One easy way is to give a semaphore semGive(getAccess); /* re-enable interrupts*/ intUnlock(); return; } Once your interrupt handler has been installed using intConnect(), the kernel will call your ISR when the CPU receives an interrupt from the device.\nBlock Drivers # A block device is a device that is organized as a sequence of individually accessible blocks of data. A block is the smallest addressable unit on a block device. Block devices have a slightly different interface than that of other IO drivers. Rather than interacting directly with the IO system, block drivers interact via file-system. The file system in turn interacts with the IO system. Every block device is typically associated with a specific file system. DOS, SCCI, and raw file systems are supported.\nBlock devices are divided into two categories based on their write capabilities. Direct Access BLOCK Devices are slightly different from SEQUENTIAL Devices in that data can be written only to the end of written medium for sequential devices, where as for true block devices, data can be written any where randomly.\nThere is no difference between BLOCK and Sequential devices as far as reading from the device is concerned.\nA device driver for a block device must provide a means for creating logical device structure, a BLK_DEV for direct access block devices and SEQ_DEV for sequential block devices. BLK_DEV/SEQ_DEV structures describe the device, contain routines to access the device, describe the device in a general fashion so that the underlying file system that serves this device can know about this device.\nPoints to remember When the driver creates the block device, the device has no name or file system associated with it. These are assigned during the device initialization routine for the specific file system (example dosFsDevInit()). The low-level driver is not installed in the IO system driver table. Instead the underlying file system is installed as an entry into the driver table. Only one entry of file system is installed even if multiple devices are using this file system. The following three steps are involved in writing a Block device driver. I shall explain this example by using ram driver with DOS as the underlying file system.\nRam driver emulates a disk driver, but actually keeps all data in memory. The memory location and size are specified when the \u0026ldquo;disk\u0026rdquo; is created. The RAM disk feature is useful when data must be preserved between boots of VxWorks or when sharing data between CPUs. The RAM driver is called in response to ioctl() codes in the same manner as a normal disk driver. When the file system is unable to handle a specific ioctl() request, it is passed to the ramDrv driver. Although there is no physical device to be controlled, ramDrv does handle a FIODISKFORMAT request, which always returns OK. All other ioctl() requests return an error and set the task\u0026rsquo;s errno to S_ioLib_UNKNOWN_REQUEST.\nStep 1: Initialize and finish the interfaces within BLK_DEV structure Declare all your data structures, create your semaphores, initialize the interrupt vectors and enable the interrupts just as been discussed for character devices. This step is required, only when you are creating your own device and not making use of existing block devices (like ram drive, scsi device etc.,) supported by VxWorks. Check VxWorks reference manual and programmers guide before you fill out the interfaces.\nPoints to remember If these interfaces are filled, the file system will call them for you, if not it will call the default routines of the file system itself.\nBLK_DEV is a structure that has the address of certain routines. If you decided to fill the structure, just declare the required interfaces and pass the address of the interfaces to BLK_DEV.\nDeclare your private device descriptor structure. Or you can directly use BLK_DEV structure.\ntypedef struct { BLK_DEV myDev; Bool privateData; Semaphore giveAccess; } DEVICE; The various fields within BLK_DEV structure are\nbd_blkRd: Address of driver routine that reads blocks from the device, if your device is myBlkDevice, then call this routine as myBlkDevRd.\nSTATUS myBlkDevRd( DEVICE * pDev,\t/* pointer to driver\u0026#39;s device descriptor. * The file system passes the address of BLK_DEV structure. * These two are equivalent because BLK_DEV is the first item of DEVICE structure */ Int startBlk, Int numBlks, Char * pBuf\t/*the address where data read is copied to */ ); bd_blkWrt: Address of driver routine that writes blocks to the device\nSTATUS myBlkDevWrt( DEVICE * pDev,\t/* pointer to driver\u0026#39;s device descriptor. */ Int startBlk, Int numBlks, Char * pBuf\t/*the address where data is copied from and written to the device */ ); bd_ioctl: Address of driver routine that performs the device IO control\nSTATUS myBlkDevIoctl( DEVICE * pDev,\t/* pointer to driver’s device descriptor. */ Int functioncode, /* ioctl function code */ Int arg ); bd_reset: Address of driver routine that performs the device reset. Null if none\nSTATUS myBlkDevReset( DEVICE * pDev,\t/* pointer to driver’s device descriptor. */ ); bd_statusChk: Address of driver routine that checks the device status. Null if none\nSTATUS myBlkDevStatus( DEVICE * pDev, /* pointer to driver’s device descriptor. */ ); bd_removable: TRUE if the device is removable(like floppy)\nbd_nBlocks: Total number of blocks on the device\nbd_nbytesPerBlk\nbd_lksPerTrack\nbd_nHeads\nbd_retry: Number of times to retry failed reads or writes\nbd_mode: Deice mode (write protected etc.,), typically set to O_RDWR\nbd_readyChanged: True if the device ready status has changed. Defaults to true\nA similar structure SEQ_DEV needs to be filled if your device is sequential.\nStep 2: Create your device Include your header files for the file system library. In our case it is dos file system. The libaray is dosFsLib.\nBLK_DEV *pBlkDev;\t// declare your BLK_DEV structure DOS_VOL_DESC *pVolDesc; PBlkDev = ramDevCreate(0, 512, 400, 400, 0); PvolDesc = dosFsMkfs(\u0026#34;DEV1:\u0026#34;, PblkDev); Explanation about the above code.\nBLK_DEV *ramDevCreate ( char * ramAddr, /* where it is in memory (0 = malloc) */ int bytesPerBlk, /* number of bytes per block */ int blksPerTrack, /* number of blocks per track */ int nBlocks, /* number of blocks on this device */ int blkOffset /* no. of blks to skip at start of device */ } if you have already pre-allocated memory, pass the address as the first argument. If not, VxWorks will allocate memory on your behalf using malloc, if you pass zero as the first argument.\nDOS_VOL_DESC *dosFsMkfs ( char * volName, /* volume name to use */ BLK_DEV * pBlkDev /* pointer to block device struct */ ) dosFsMkfs routine calls dosFsDevInit() with default parameters and initializes the file system on the disk by calling ioctl() with FIODISKINIT.\nDOS_VOL_DESC *dosFsDevInit ( char * devName, /* device name */ BLK_DEV * pBlkDev, /* pointer to block device struct */ DOS_VOL_CONFIG * pConfig /* pointer to volume config data */ ) This routine takes a block device structure (BLK_DEV) created by a device driver and defines it as a dosFs volume. As a result, when high-level I/O operations (e.g., open(), write()) are performed on the device, the calls will be routed through dosFsLib. The pBlkDev parameter is the address of the BLK_DEV structure which describes this device. This routine associates the name devName with the device and installs it in the VxWorks I/O system’s device table. The driver number used when the device is added to the table is that which was assigned to the dosFs library during dosFsInit(). (The driver number is placed in the global variable dosFsDrvNum.)\nThe BLK_DEV structure contains configuration data describing the device and the addresses of five routines which will be called to read sectors, write sectors, reset the device, check device status, and perform other control functions (ioctl()). These routines will not be called until they are required by subsequent I/O operations.\nThe pConfig parameter is the address of a DOS_VOL_CONFIG structure. This structure must have been previously initialized with the specific dosFs configuration data to be used for this volume. This structure may be easily initialized using dosFsConfigInit(). If the device being initialized already has a valid dosFs (MS-DOS) file system on it, the pConfig parameter may be NULL. In this case, the volume will be mounted and the configuration data will be read from the boot sector of the disk. (If pConfig is NULL, both change-no-warn and auto-sync options are initially disabled. These can be enabled using the dosFsVolOptionsSet() routine.)\nStep 3: Finish your ISR Finish your interrupt handler routine. You just need to connect the ISR using intConnect.\nReal World Scenarios # I will cover two sample drivers. The first one is a standard serial driver. The second one is a hypothetical network processor driver, which doesn\u0026rsquo;t follow the required conventions. Both of these are character drivers.\nSerial Driver # This driver deals with PowerPC 8245 DUART. You can download PPC 8245 manual online from here MPC8245. Look into chapter 11 and 12 of this manual. This example deals with NS16550 or equivalent UART (Universal Asynchronous Receiver Transmitter).\n// forward declare our interrupt handler void DuartISRHandler(); #define EUMBARR_BASE\tDEFINE_YOUR_OWN #define DUART_CH1_IVR\tEUMBARR_BASE+0x51120 #define IACK_REG\tEUMBARR_BASE+0x600A0 #define EOI_REG\tEUMBARR_BASE+0x600B0 Embedded utilities Block(EUMBARR) holds the EPIC register definition. It serves as an offset for the rest of the registers within EPIC unit. The programming model of EPIC is as follows.\nset the required interrupt vector/priority register. In this case we are interested in DUART channel 1 IVR. Once an interrupt occurs, EPIC will notify the CPU. CPU has to read the interrupt acknowledge register to determine the interrupt source. Most of the times this portion will be taken care for your by the BSP(Board support package) and the kernel. But I will show you how to do this. Typically your kernel will determine the source and call the installed interrupt handler. Once you have finished your work within ISR, you have to return. Your kernel will typically write to EOI register. I will show this step too. #define\tDCR\tEUMBARR_BASE+0x4511 #define\tULCR\tEUMBARR_BASE+0x4503 #define\tUFCR\tEUMBARR_BASE+0x4502 #define\tUIIR\tUFCR #define\tURBR\tEUMBARR_BASE+0x4500 #define\tUTHR\tURBR #define\tUDLB\tURBR #define\tUIER\tEUMBARR_BASE+0x4501 #define\tUDMB\tUIER #define\tULSR\tEUMBARR_BASE+0x4505 #define\tUDSR\tEUMBARR_BASE+0x4510 Let us get into details about the DUART itself . Refer to 12.3 DUART initialization sequence.\n/* * declare buffersize to be greater then 14. * This the value we set for FIFO capacity, 14 bytes of data. * We make use of a ring buffer to handle the incoming and out going data. * A ring Buffer is a circular array (liner array around which we wrap around). * */ #define BUF_SIZE 141 typedef struct { DEV_HDR DuartHdr; Char readBuf[BUF_SIZE]; Char writeBuf[BUF_SIZE]; Int readCount; Int readPtr; Int writePtr; Int writeCount; Int mode; BOOL intUse; Semaphore getRDAccess; Semaphore getWRAccess; } MY_DEV; /* some global definitions */ MY_DEV gDuartStruct; Static int gDuartDrvNum; STATUS DuartInit() { *ULSR = 0;\t/* This lets access to UDLB, UAFR and UDMB. */ *UDLB = 1; *UDMB = 0; /* we have set divisor to be 16, the max baud rate allowed. */ *UAFR = 0;\t/* disable concurrent writes */ *ULSR = (1 \u0026lt;\u0026lt; 1) | 1;\t/* set bit 8 bit characters (bits 0 and 1) */ *DCR = 0; /* route the interrupts to EPIC in four signal mode */ *UIER = (1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 1) | 1; /* we are not setting modem status. We program assuming no modem is going to be connected. */ *UFCR = (1 \u0026lt;\u0026lt; 7) | (1 \u0026lt;\u0026lt; 6) | (1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 1) | 1; /* enable the FIFO Tx and Rx for 14 bytes */ *DUART_CH1_IVR = 0; /* clear it first; */ int priority = 16; /* actual priority will be 1 */ int vector = 0x7; /* the vector number associated with UART interrupt. * make sure no one else has this vector already taken. * It returns vector 128 when IACK register is read. * */ *DUART_CH1_IVR = (1 \u0026lt;\u0026lt; priority) | (1 \u0026lt;\u0026lt; vector); gDuartDrvNum = iosDrvInstall(myDevCreate /* create */ , 0 /* remove() is null */ , DuartOpen /* open() */ , DuartClose /* close() */ , DuartRead /* read() */ , DuartWrite /* write() */ , DuartIoctl /* ioctl() */ ); // register our ISR intConnect(128, DuartISRHandler, 0); gDuartStruct.getWRAccess = semBCreate(SEM_Q_PRIORITY, SEM_FULL); gDuartStruct.getRDAccess = semBCreate(SEM_Q_PRIORITY, SEM_EMPTY); } Inside the DuartInit routine, we initialized various registers. One point to note is we created two semaphores, one for read and one for write. They protect the read and write buffers readBuf and writeBuf. getWRAccess has been created full, meaning the write semaphore is available immediately for access, which indicates that the user can write to the DUART and writeBuf can hold bytes. getRDAccess has been created empty, meaning there is no data available for reading immediately from readBuf, until someone gives the semaphore.\nSemaphores are taken in read and write routines and given in the ISR. ISR can modify readPtr and writeCount. It doesn\u0026rsquo;t modify writePtr and readCount. DuratRead() routines modifies readCount and doesn\u0026rsquo;t modify readPtr. DuratWrite() routine modifes writePtr and doesn\u0026rsquo;t modify writeCount. This way, I am making sure that no race conditions exisit.\nSTATUS DuartCreate(char *name, …) { MY_DEV *pDuart = \u0026amp;gDuartStruct; status = iosDevAdd(pDuart, /* pointer to MY_DEV device */ name, /* input param */ gDuartDrvNum /* return value from iosDrvInstall */ ); } STATUS DuartOpen(MY_DEV * pDuart, char *remainder, int mode) { /* serial devices should have no file name remainder */ /* if multiple opens occur, we reject, note that I have not protected inUse variable here. They should be protected */ if (remainder[0] != 0 || pDuart-\u0026gt;intUse) { return ERROR; } else { pDuart-\u0026gt;intUse = true; // only one access at a time pDuart-\u0026gt;mode = mode; return (int)pDuart; } } STATUS DuartClose(char *name, …) { pDuart-\u0026gt;intUse = false; return OK; } // read from the DUART and Put it into the buffer // here we will not always be able to read the required number of bytes for two reasons. // 1) Not enough data is available // 2) We code it little lazy, and the user has to do one more read to get the data, if readPtr has wrapped around // we manipulate pDuart-\u0026gt;readPtr only in the ISR and pDuart-\u0026gt;readCount from this code to avoid race conditions STATUS DuartRead(MY_DEV * pDuart, char *buffer, int nBytes) { /* read nBytes from the device and put them into the buffer */ /* define RDMASK and WRITEMASK */ if (pDuart-\u0026gt;mode \u0026amp; RDMASK) // if it is readable { } /* this is a blocking call. * If there is no data available, we cannot proceed further, * until data arrives and we release the semaphore from the ISR. */ semTake(pDuart-\u0026gt;getRDAccess, WAIT_FOREVER) /* grab whatever data is available and return it, * don\u0026#39;t wait till you get all the required nBytes data. */ int NumBytestoRead = 0; int I = 0; int readPtr = pDuart-\u0026gt;readPtr; NumBytestoRead = readPtr - pDuart-\u0026gt;readCount; if (pDuart-\u0026gt;readCount \u0026gt;= readPtr) { // no race condition detected while ((NumBytestoRead \u0026gt; 0) \u0026amp;\u0026amp; (pDuart-\u0026gt;readCount \u0026gt; readPtr)) { buffer[I] = pDuart-\u0026gt;readBuf[pDuart-\u0026gt;readCount++]; I++; pDuart-\u0026gt;readCount %= BUF_SIZE; NumBytestoRead--; } } if (pDuart-\u0026gt;readCount \u0026lt; readPtr) { while ((NumBytestoRead \u0026gt; 0) \u0026amp;\u0026amp; (pDuart-\u0026gt;readCount \u0026lt; readPtr)) { buffer[I] = pDuart-\u0026gt;readBuf[pDuart-\u0026gt;readCount++]; I++; NumBytestoRead--; } } return I; } /* write to the device from buffer if the device has room */ // We manipulate the writePtr from here and writeCount from the ISR STATUS DuartWrite(MY_DEV * pDuart, char *buffer, int nBytes) { // define RDMASK and WRITEMASK if (pDuart-\u0026gt;mode \u0026amp; WRITEMASK) // if it is writeable mode { } Int NumBytestoWrite = nBytes; Int I = 0; Int writeCount = pDuart-\u0026gt;writeCount; if (pDuart-\u0026gt;writePtr \u0026gt;= writeCount) { // no race condition detected while ((NumBytestoWrite \u0026gt; 0) \u0026amp;\u0026amp; (pDuart-\u0026gt;writePtr \u0026gt;= writeCount)) { pDuart-\u0026gt;writeBuf[pDuart-\u0026gt;writePtr++] = buffer[I]; I++; pDuart-\u0026gt;writePtr %= BUF_SIZE; NumBytestoWrite--; } } if (pDuart-\u0026gt;writePtr \u0026lt; writeCount) { while ((NumBytestoWrite \u0026gt; 0) \u0026amp;\u0026amp; (writeCount \u0026gt;= pDuart-\u0026gt;writePtr)) { pDuart-\u0026gt;writeBuf[pDuart-\u0026gt;writePtr++] = buffer[I]; I++; NumBytestoWrite--; } } return I; } IOCTL requires some explanation. IOCTL provides an interface for a user to control the device, and is the preferred way of controlling the device. The implementation of IOCTL is dependant upon the way your device performs and how you want to control the device.\nSTATUS DuartIoctl(MY_DEV* pDuart, int command, int baudrate) { switch(command) { CASE SET_DEVICE: /* set the device*/ break; CASE MODIFY_BAUD: // our argument has the new baud rate. // we will have to modify the registers to set the baud rate // you need to know the clock frequency of your CPU. // assume it is a global value int divisor = clock_frequency/ (baud* 16); // UDLB is the least significant byte register and UDMB is the most significant. // each register is 8 bits wide, so the max value for 8 bits of data is 255. // if divisor is less then 256, we assign it to UDLB and make UDMB zero. If(divisor \u0026lt; 256) { *UDLB = divisor; } else { *UDMB = divisor - 255; *UDLB = 255; } break; default: break; } } Let us finish the interrupt handler routine. We enter into the handler after the kernel has determined that the vector within IACK register matches to DuartISRHandler.\n// The logic for the code is as follows\nread interrupt read register UIIR if error occurred, read ULSR read URBR, if data is recd. This will clear the UIIR write to UTHR, if FIFO is empty. This will clear the UIIR #define lastThreeBits\t(1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 1) #define RxLineError\t(1 \u0026lt;\u0026lt; 2) | (1 \u0026lt;\u0026lt; 1) #define RxDataAvailable\t(1 \u0026lt;\u0026lt; 2) #define charTimeOut\t(1 \u0026lt;\u0026lt; 3) | (1 \u0026lt;\u0026lt; 2) #define uthrEmpty\t(1 \u0026lt;\u0026lt; 1) #define RFE\t(1 \u0026lt;\u0026lt; 7) #define FE\t(1 \u0026lt;\u0026lt; 3) #define TxEmpty (1 \u0026lt;\u0026lt; 6) #define TxHrEmpty (1 \u0026lt;\u0026lt; 5) void DuartISRHandler() { int oldlevel = intLock();\t// let us lock interrupts unsigned char regUIIR = *UIIR; switch(regUIIR \u0026amp; lastThreeBits) { // we handle both cases in the same fashion CASE RxLineError: CASE uthrEmpty: // ULSR gives us the status of the interrupt that just occurred on the DURAT. unsigned char regULSR = *ULSR; if(regULSR \u0026amp; RFE) { // Framing Error logMsg(\u0026#34;Framing Error DUART\u0026#34;); } if((regULSR \u0026amp; TxEmpty) || (regULSR \u0026amp; TxHrEmpty)) { // Tx is empty, we can write more to the device. if(gDuartStruct.writeCount \u0026gt; gDuartStruct.writePtr) { While(!(*UDSR \u0026amp; 2) \u0026amp;\u0026amp; (gDuartStruct.writeCount \u0026gt;= gDuartStruct.writePtr)) { *UTHR = writeBuf[gDuartStruct.writeCount++]; gDuartStruct.writeCount %= BUF_SIZE; } } if(gDuartStruct.writeCount \u0026lt;= gDuartStruct.writePtr) { while(!(*UDSR \u0026amp; 2) \u0026amp;\u0026amp;(gDuartStruct.writeCount \u0026lt;= gDuartStruct.writePtr)) { *UTHR = writeBuf[gDuartStruct.writeCount++]; } } // indicate to the user that write buffer can be filled. semGive(gDuartStruct.getWRAcess); } break; // end case CASE RxDataAvailable: if(gDuartStruct.readPtr \u0026gt; gDuartStruct.readCount) { while(!(*UDSR \u0026amp; 1) \u0026amp;\u0026amp; (gDuartStruct.readPtr \u0026gt; gDuartStruct.readCount)) { readBuf[gDuartStruct.readPtr++] = *URBR; gDuartStruct.readPtr %= BUF_SIZE; } } if(gDuartStruct.readPtr \u0026lt; gDuartStruct.readCount) { while(!(*UDSR \u0026amp; 1) \u0026amp;\u0026amp; (gDuartStruct.readCount \u0026gt;= gDuartStruct.readPtr)) { readBuf[gDuartStruct.readPtr++] = *URBR; } } // indicate to the user that read buffer has more data. semGive(gDuartStruct.getRDAcess); } intUnlock(oldlevel); // re-enable interrupts } Once we left the ISR, the kernel will call EOI (end of Interrupt) and will notify the CPU.\nIn the real world however, many times you will not be using all the interface functions. So your design will not involve adding a device (iosDevAdd), installing interfaces (iosDrvInstall) etc,.\nYou directly declare your ISR and connect it to a particular vector. After that you can communicate to your device back and forth via interrupts and via user task that processes the responses from the ISR.\nHere is a diagram which helps you understand more clearly.\nUser Interaction with a driver # Once you have compiled your driver module, you can link it statically or load it dynamically.\nFor the DUART driver to be used, you have to install the device and add the device. You can modify your DuartInit routine to automatically call DuartCreate function.\nfd = DuartCreate(\u0026#34;/duart0\u0026#34;); Make sure your DuartInit is called during your system initialization, say at the end of SysHardwareInit()\nWrite a user application to use the duart by using the following code.\nOpen the device with required permissions.\nif((fd=open(\u0026#34;/duart0\u0026#34;, O_RDWR, 0666)) == ERROR) { } else { // you can read and write to the device write(fd, buf, size); read(fd, buf, size); close(fd); } For debugging your driver, connect your Tornado and use GDB.\nAdvanced Topics # Context Switching # When the scheduler preempts a task it has to store the current state of the task in task\u0026rsquo;s context storage area and will retrieve it later when the task is resumed. The current runnable tasks context is retrieved. This process of switching the contexts is called task switching or context switching.\nThe highest priority task always runs till it requires no CPU time. Higher priority tasks that are made ready preempt the currently executing task. A context switch can occur by the currently executing task relinquishing control, or a higher priority task becoming ready. A currently executing task can relinquish control via a blocking call, which suspends task execution until the blocking requirement is met, or if a timeout of a blocking call invoked by a higher priority task occurs. A higher priority task may become available also via a blocking call requirement fulfilled resulting in the operating system performing a context switch, or a timeout on a blocking call occurring as previously mentioned. Interrupt handlers and currently executing tasks are common ways to initiate a context switch that results in the execution of a higher priority task. Interrupt Service Routines (ISR) do not have a persistent context. ISRs have a transient execution context that executes at a higher priority than a task. Therefore, interrupt handlers preempt a task irrespective of the task\u0026rsquo;s priority. Due to the transient nature of ISRs, they should not perform any blocking operation and therefore can not invoke a system call, or any routine, that does such. An ISR that attempts to block will more than likely result with the system in a deadlock state. Therefore special attention should be given to any calls made, or actions taken, from within the context of an ISR. It is possible for an ISR to preempt another ISR, however this is board dependent and may not be allowed. The handling of the hardware interrupt, that in turn invokes the ISR registered for the interrupt, is board specific and is performed by the board support package software (BSP). VxWorks provides an API that allows the developer to register an ISR with the BSP\u0026rsquo;s board specific handler. This abstraction layer allows for board specific code to be segregated from the remainder of the application thus allowing for easier porting to new board types. You can tell the system not to preempt your code by using taskLock() and release it later once you finished your critical section code using taskUnlock(). Note this is not a suggested mechanism, as your code cannot be interrupted. Also this might lead to unacceptable real time behavior, because a higher priority task can preempt a lower priority task that locked itself. Reentrancy # If a piece of code can be used by more then one task without the fear of data corruption, then it is said to be Reentrant. A reentrant function can be interrupted at any time and resumed latter without loss or corruption of data.\nTo achieve reentrancy, use either local variables (i.e variables on stack rather then on heap, and CPU registers etc.,) or treat the code as critical section and protect the data. Most library routines are reentrant within VxWorks. If a function ends with _r(), then it is non reentrant.\nPriority inheritance # Assume three tasks t1, t2, t3 with task priorities p1, p2, p3 such that p1 \u0026gt; p2 \u0026gt; p3. If task t3 is currently executing and holds access to shared resource s1 (ex. by holding a semaphore sem1), and if t1 preempts t3 and wants to access s1 via the sem1, t1 will be suspended as soon as it wants to access sem1, which is held by t3. So to prevent deadlock, priority of task t3 will be made greater than or equal to that of t1 (i.e p3 \u0026gt;= p1) till t3 gives the semaphore and relinquishes it\u0026rsquo;s access to s1. Tasks t2 and t1 cannot preempt t3 until t3 gives sem1.\nTo support priority inversion, RTOS should support dynamic priorities.\nAddress space # In VxWorks, all code and text live together in a single address space. (VxWorks has come up with new version called AE which has different user and kernel address spaces). So if your code is poorly written, it can actually enter the kernel text and corrupt the OS, which can cause some serious problems. Having a single common address space improves the performance of your system. When you are using virtual memory, you still have to map between virtual and physical memory within your driver.\nCache Coherency # Depending upon your processor and BSP design, typically CPU caches data and instructions for improved performance. If you are DMAing data between your device and RAM, then your driver should guarantee cache coherency. This is typically done in two ways.\nMark a portion of memory within your RAM as non-cachable. Allocate cache safe buffers from this memory. Alternatively, use cacheFlush() and cacheInvalidate() routines provided by VxWorks. If Device is reading data from RAM, first flush the cache and then read data. If Device is writing to RAM, write to RAM and then invalidate the cache immediately. This way CPU\u0026rsquo;s cache will be in sync with RAM. Implementing Select Call # Select call lets your driver support multiple devices and a task can wait on all or some of these devices at the same time for at least one of the devices to be ready for IO. These tasks can specify timeout period for the devices to become ready.\nMost of the functionality for select call is supported in selectLib library. Your ioctl() is called whenever user calls select() with an argument FIOSELECT. To support select() call,\nDeclare SEL_WAKEUP_LIST as part of your device descriptor structure and initialize it by calling selWakeupList within your xxDevCreate() routine. Add SEL_WAKEUP_NODE, which is the third argument to your ioctl(), to the wakeup list. Use selWakeupType to determine if the task is waiting for read or write. If the device is ready, call selWakeupAll, to unblock all tasks waiting. Implement FIOUNSELECT to delete a node ","date":"2024-10-05","externalUrl":null,"permalink":"/bsp/vxworks-5-4-device-driver-development/","section":"Board Support Package","summary":"\u003ch1 class=\"relative group\"\u003ePreface \n    \u003cdiv id=\"preface\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#preface\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eThis guide is for device driver developers, who have general background in real time operating systems. This guide addresses device driver development using VxWorks 5.4/Tornado 2.0.\u003c/p\u003e","title":"VxWorks 5.4 Device Driver Development","type":"bsp"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/arm/","section":"Tags","summary":"","title":"ARM","type":"tags"},{"content":" Learning Objectives # This application note has provided step-by-step instructions for running the VxWorks 6.9.3.1 BSP on the Zynq-7000 SoC All Programmable device platform, and additionally provided an overview of the boot process for the Zynq-7000 AP SoC platform.\nYou will know the steps for using VxWorks RTOS on the Zynq-7000 AP SoC platform.\nSummary # VxWorks from Wind River:\nIs a Real Time Operating system (RTOS). Is a platform-based approach with configurable components that relate to different architecture support, network, file system, compiler and development tool chains. Supports the Zynq®-7000 All Programmable (AP) SoC architecture of multicore processor systems. Has support for asymmetric multiprocessing (AMP) and symmetric multiprocessing (SMP). This application note is intended as a getting started guide for new users of VxWorks on the Zynq-7000 device. The document contains the following primary sections:\nIntroduction: Explains the important elements of the Zynq-7000 software environment to provide a better understanding of BSP and application generation. This includes the: ROM mechanism Function of the first stage bootloader (FSBL) Wind River bootloader Explanation of the Zynq-7000 processor subsystem boot process Building VxWorks for Zynq-7000 AP SoC, page 5: Explains native flash (SD Card) and remote Ethernet (FTP) boot source options and the bootloader configurations for both options. Building and Debugging the Application, page 17: Explains how to create, build and remotely run a custom application with VxWorks on a Zynq-7000 device. Accessing a Peripheral in the Processing System, page 20: Describes how to access peripheral systems in the Zynq-7000 Processing System (PS). Conclusion, page 25: Summarizes what this application note describes. Additional Resources, page 25: Provides additional resource links. This document assumes familiarity with the Xilinx® ISE® Design Suite and Zynq-7000 AP SoC design methodology. This document includes a reference system for the Xilinx ZC702 board derived from the Zynq-7000 AP SOC - Concepts, Tools and Techniques User Guide [Ref 1], which provides the details on how to rebuild such a system. Hardware and Software Requirements # Software Requirements # Xilinx® ISE® Design Suite: Embedded or System Edition 14.6 or Vivado® Design Suite, 2013.2. Wind River Workbench for VxWorks 6.9.3, which includes a Zynq-7000 AP SoC BSP Serial Communication utility program (such as Tera Term) Hardware Requirements # Xilinx ZC702 Development Board Ethernet Cable USB UART Cable Introduction # The Zynq-7000 AP SOC devices takes advantage of the on-chip CPU to facilitate configuration. Initial device configuration of the processing system (PS) and the programmable logic (PL) must take place through the PS when not using JTAG.\nTwo major blocks control the configuration:\nThe first is the BootROM which is a static block of memory that is executed by the multiprocessor core after power-on reset and warm reset. The second major block is the device configuration unit which controls JTAG debug access and provides an interface to the AES, HMAC, and PCAP blocks for PL configuration and data decryption. Both the PS and PL can be configured under PS control either securely or non-securely. Configuration under external host control is also possible using JTAG.\nUnlike other Xilinx 7 series devices, Zynq-7000 AP SOC devices do not support initial PL controlled configuration. Configuration on the Zynq-7000 AP SOC devices is a multi-step process. The configuration process involves a minimum of two stages, but generally requires three stages.\nThe stages are:\nStage 0: BootROM, page 3: Referred to as the BootROM, this stage controls initial device startup. The BootROM is non-modifiable code executed by the processor after power-on reset and warm reset. Stage 1: First Stage Bootloader, page 4: This is generally a first stage boot loader (FSBL), but it can be any user-controlled code. See the Zynq-7000 AP SOC Software Developers Guide (UG821) [Ref 1] for details about FSBL. Stage 2: VxWorks Bootloader, page 4: This is generally user-configurable software that can act as a second stage boot loader (SSBL). This stage is completely within user control. In the case of this document, it is part of the VxWorks bootloader. Figure 1 below illustrates a non-secure boot process for typical Linux system. Uboot is an example for higher-level boot loader and can be exchanged by VxWorks bootloader.\nFigure 1: Boot Flow Stage 0: BootROM # The Zynq-7000 AP SoC processor subsystem configuration starts after power-on reset. The ARM® CPU starts executing code from the on-chip BootROM with JTAG disabled. The BootROM contains code for base drivers for NAND, NOR, Quad-SPI, SD, and PCAP. DDR and other peripheral initializations are not performed from the BootROM and must be done in the Stage 1 image, First Stage Bootload (FSBL) or later.\nFor security, the CPU is always the first device out of reset among all master modules within the PS. When the BootROM is running the JTAG is disabled to ensure security.\nThe BootROM code is also responsible for loading the FSBL. Zynq-7000 AP SoC architecture supports multi-stage user boot image loading; any further user boot image loading after FSBL is the responsibility of the user. When the BootROM releases control to FSBL, user software assumes full control of entire system. The only way to execute the BootROM again is by performing a reset.\nThe PS boot source is selected using the mode-pin signals (indicated by a weak pull-up or pull-down applied to specific pins), which are sampled after during power-on reset. The sampled value is stored in the BOOT_MODE register.\nThe BootROM supports encrypted and unencrypted images referred to as secure boot and non-secure boot, respectively. Additionally, the BootROM supports beginning execution of the stage 1 image from OCM after copying the image or executing direct from linear flash (NOR or QSPI) when using the execute-in-place (XIP) feature.\nIn secure boot the CPU, running from secure BootROM code, decrypts and authenticates the incoming user PS image, stores it in the OCM RAM, and then branches into that RAM. In non-secure boot the CPU, running from BootROM code, disables all secure boot features including the AES engine within the PL before branching to the user image in the OCM RAM or flash, if XIP is used. The Processor System (PS) boot image is limited to 192 KB unless booting with XIP. Any subsequent boot stages for either the PS or the PL are the responsibility of the user and are under user control. The BootROM code is not accessible to the user.\nFollowing the stage 1 secure boot, you can proceed with either secure or non-secure subsequent boot stages. Following a non-secure first stage boot, only non-secure subsequent stage boots are possible. For secure boot decryption and authentication, the PS uses the hard-wired AES-256 and SHA-256 modules within the PL. For this reason, the PL must be powered up during any secure boot, even if only the PS is configured. The device encryption key is user-selectable from either the on-chip eFUSE unit or the on-chip block RAM.\nThe possible boot sources are: NAND, NOR, SD, Quad-SPI, and JTAG. The first four boot sources are used in master boot methods in which the CPU loads the external boot image from nonvolatile memory into the PS.\nStage 1: First Stage Bootloader # The First Stage Bootloader (FSBL) starts after the execution of the BootROM. BootRom loads the FSBL into the OCM, or the FSBL executes in place (XIP) unencrypted from memory mapped flash (NOR or Quad-SPI), contingent upon the BootROM header description.\nThe FSBL is responsible for:\nInitialization using the PS configuration data provided by Xilinx Platform Studio (XPS) (see \u0026ldquo;Zynq-7000 PS Configuration\u0026rdquo; in the Zynq-7000 AP SOC Software Developers Guide (UG821) [Ref 2]. Programming the PL using a bitstream Loading second stage bootloader or bare-metal application code into DDR memory Starting execution of the second stage bootloader or bare-metal application Note: Before handoff to the second stage bootloader or bare-metal application, the FSBL invalidates the instruction cache and disables the cache and MMU, because Linux (and perhaps other operating systems) assume it is disabled upon start.\nSee the FSBL code provided with SDK for details on how the FSBL initializes the CPU and peripherals used by the FSBL, and how it uses a simple C run time library.\nThe bitstream for the PL and the second stage bootloader or bare-metal application data, as well as other code and data used by the second stage bootloader, Linux (or other operating system), or bare-metal application are grouped into partitions in the flash image.\nStage 2: VxWorks Bootloader # The VxWorks bootloader application loads a VxWorks image onto a target. Like VxWorks, you can configure the VxWorks bootloader with various facilities; such as a command line interface for dynamically setting boot parameters, a network loader, and a file system loader.\nUniprocessor (UP), symmetric multiprocessor (SMP), and asymmetric multiprocessor (AMP), configurations of VxWorks use the same bootloader.\nIn a development environment, a bootloader is useful for loading a VxWorks image from a host system, where you can modify and rebuild VxWorks. You can also use a VxWorks bootloader in production systems when the bootloader and operating system are stored on a disk or other media.\nSelf-booting (standalone) VxWorks images do not require a bootloader. These images are commonly used in production systems (stored in nonvolatile devices).\nUsually, the bootloader is programmed in a nonvolatile device (usually flash memory or EEPROM) at an address such that it is the first code run by the processor when the target is powered on or rebooted. The procedure to get the boot loader programmed in a nonvolatile device or written to a disk is dependent on the target, and is described in following section using an SD card image.\nThe VxWorks product installation includes default bootloader images for each installed BSP. If they do not meet your needs, you can create a custom bootloader.\nBuilding VxWorks for Zynq-7000 AP SoC # Host Environment Configuration # The following steps are one-time only:\nInstall VxWorks Tool chain 6.9.3.1. Install Base Tools Package. Invoke the Product Maintenance GUI. Update the installer. Configure online Content Update Network settings. Apply updates based upon your license file, as shown in Figure 2. Figure 2: Select Products Dialog Box The Zynq-7000 BSP is a standard part of the 6.9.3.1 install, as shown in Figure 3:\nFigure 3: VxWorks BSP: Xilinx Zynq-7000 EPP Because of the asynchronous nature of VxWorks BSPs, verify that you install the latest Xilinx BSP. The link is provided at [Ref 4]. Install the BSP patches as described in the BSP download link: VxWorks 6.9.3.1 BSP Driver Source Patch for BSP, The link is provided at [Ref 5]. Complete all details of the build steps to apply the patch into the source tree. Configure and Build a VxWorks BootROM and Kernel Image # The default BSP does not enable support for accessing an SD card. Because you use the SD card to store the VxWorks image, the first step is to modify the BSP configuration.\nIn a text editor, open the \u0026lt;Install_Dir\u0026gt;/vxworks-6.9/target/config/xlnx_zynq7k/config.h file, and modify line 197: #undef DRV_STORAGE_SDHC/ -\u0026gt;\n#define DRV_STORAGE_SDHC #define INCLUDE_DOSFS #define INCLUDE_DOSFS_MAIN #define INCLUDE_DOSFS_CHKDSK #define INCLUDE_DOSFS_FMT #define INCLUDE_DOSFS_FAT #define INCLUDE_DOSFS_SHOW #define INCLUDE_DOSFS_DIR_VFAT #define INCLUDE_DOSFS_DIR_FIXED #define INCLUDE_FS_MONITOR #define INCLUDE_FS_EVENT_UTIL #define INCLUDE_ERF #define INCLUDE_XBD #define INCLUDE_XBD_BLKDEV #define INCLUDE_XBD_TRANS #define INCLUDE_DEVICE_MANAGER #define INCLUDE_XBD_BLK_DEV #define INCLUDE_XBD_PART_LIB #define INCLUDE_DISK_UTIL This enables the SDHC controller, as well as drivers for the FAT file system.\nTo use the VxWorks BSP with the Wind River Workbench to create a VxWorks Kernel Image, do the following:\nStart the Wind River Workbench tool and select a workspace. The Wind River SDK opens.\nIn the main context menu select File \u0026gt; New \u0026gt; Project. The New Project Wizard opens.\nUnder VxWorks 6.x, select the VxWorks Image Project, as shown in Figure 4. Figure 4: VxWorks Image Project The New VxWorks Image Project multipage wizard opens.\nEnter a project name, for example, zynq_vxworks_01, and click Next.\nSelect the xlnx_zynq7k BSP used for this project as highlighted in Figure 5. Figure 5: VxWorks Image Project Multipage Wizard From the New VxWorks Image Project wizard, select PROFILE_DEVELOPMENT (Figure 6). Figure 6: New VxWorks Image Project: PROFILE_DEVELOPMENT Option Click Finish.\nOpen the Kernel configuration. Change the configuration to include the symbol table in the Kernel image (Figure 7, page 10). Figure 7: Component Configuration You can now build the Kernel image.\nBuilding the Kernel Image # In the Project Explorer window, mouse over to the Image project, right-click and select Build Project. The VxWorks image file is located in the ,./\u0026lt;project_name\u0026gt;/default directory. Figure 8 shows the Build Project option. Figure 8: Build Project Option When the project build is complete, start a Wind River VxWorks development shell. Use this shell to build a bootROM binary. The bootROM binary is the VxWorks bootloader (similar to Uboot); it is not within the Zynq-7000 device ROM.\nWithin the shell, type:\ncd ..\\\u0026lt;install_dir\u0026gt;\\WindRiver\\vxworks-6.9\\target\\config\\xlnx_zynq7k\\ make clean make bootROM The commands generate a file with the name bootROM. Rename the file to bootROM.elf\nCreate a boot.bif and a zynq_fsbl_0.elf file, with the following format: ZC702_bif_for_VxWorks: { [bootloader]zynq_fsbl_0.elf bootROM.elf } Copy the bootROM.elf, zynq_fsbl_0.elf, and the boot.bif file to the /bootgen directory. Alternatively, you can copy the bootgen.exe tool to the current installation directory.\nC:\\\u0026lt;install_dir\u0026gt;\\WindRiver\\vxworks-6.9\\target\\config\\xlnx_zynq7k\\ In the Wind River shell, type: bootgen image boot.bif I BOOT.BIN Copy the following files onto an SD card: VxWorks from the ..\u0026lt;project_name\u0026gt;\\default directory BOOT.BIN from the ..\u0026lt;install_dir\u0026gt;\\WindRiver\\vxworks 6.9\\xlnx_zynq7k\\ directory. This creates a system that can boot from an SD card.\nThe following subsection describes the required steps to boot from an SD card.\nBooting From an Secure Digital Card # Use the Secure Digital (SD) card to boot the Zynq-7000 AP SoC Processor System (PS).\nConnect a power cable, a Xilinx USB download cable, an Ethernet cable, and a USB UART cable to the board. Put the SD Card in the SD card pole of the board. Ensure that the switches for booting from SD Card are in the right position. Ensure that the settings of Jumpers J27 and J28 are the same as shown. Move the DIP-Switches 3 and 4 of SW 16 to the left (this sets the switches to 1) (Figure 9). Figure 9: Image of SD Card and USB Connection These settings ensure an SD card boot.\nOpen a terminal session, and choose the right COM port () function, and set the Baud Rate to 115200. Switch on the board. Stop the Autoboot process by pressing the keyboard Return key. The VxWorks bootROM prompt opens.\nType C at the boot prompt, and press Return to start the boot configuration. Change the boot device to fs and press Return until you reach the file name. Change to /sd0:1/vxWorks and press Return until you reach other (o). If no entry exists, type gem0. Press Return and the boot prompt opens. Type @ to proceed the boot process. Type i to display all running tasks. VxWorks boots and presents the output as shown in Figure 10.\nFigure 10: SD Boot Terminal Transcript Booting Using FTP # Repeat the first four steps shown in Booting From an Secure Digital Card, as follows:\nConnect a power cable, a Xilinx USB download cable, an Ethernet cable, and a USB UART cable to the board.\nPut the SD Card in the SD card pole of the board. Ensure that the switches for booting from SD Card are in the right position. Open a terminal session, and choose the right COM port () function, and set the Baud Rate to 115200.\nChange the local area network (LAN) connection of your system network settings to the IP address 192.168.1.1. Figure 11: Host Ethernet MAC Configuration Start an FTP server. You can use the server delivered with the Wind River tool chain. If you use the Wind River FTP server, select Security \u0026gt; User/rights.\nClick New User and type a name; for example, Zynq and a password.\nType the home directory of the VxWorks image, then click Done.\nSwitch on the board.\nStop the Autoboot process by pressing Return. The VxWorks bootROM prompt opens.\nAt the boot prompt, type c then press Return to start the boot configuration.\nType gem0 to change boot device then press Return until you reach File Name.\nType VxWorks, then press Return until you reach inet on ethernet (e).\nChange the inet on ethernet (e) to IP address 192.168.1.2:0xffffff00, then press Return until you reach host inet (h).\nChange host inet (h) IP address 192.169.1.1, then press Return until you reach user.\nType the user name you choose for the server then press Return until you reach password (pw).\nType password you choose for the server, then press Return until you reach other (o).\nIf no entry exists, type gem0, then press Return. The boot prompt opens.\nType @ to start the boot process.\nVxWorks boots from the image using the terminal (Figure 12).\nFigure 12: Boot Terminal Transcript Building and Debugging the Application # Creating the Hello World Application # As short example, the following instructions describe how to build and download a small \u0026ldquo;Hello World\u0026rdquo; application to the remote target after you have set up and are running VxWorks.\nThe assumptions are:\nYou have followed the prior stages of this document. VxWorks is executing on the target (with remote debug enabled). An Ethernet connection is present between the host and the target. To create the \u0026ldquo;Hello World\u0026rdquo; application:\nSelect File \u0026gt; New \u0026gt; Project \u0026gt; VxWorks Downloadable Kernel Module Project, as shown in Figure 13. Figure 13: New Project Wizard Click Next and enter a project name; for example, hello_world, (Figure 14), then press Finish. Figure 14: New Kernel Module Project A hello_world project opens in the Project Explorer Window.\nMove the mouse to the Project. Click the right button and select New \u0026gt; File. Enter a file name; for example, hello.c, and click Finish. Enter the following code into the file: #include \u0026lt;stdio.h\u0026gt; void hello() { printf(\u0026#34;Hello Wind River\\n\u0026#34;); } In the Project Explorer window, select Build Targets (Figure 15), and click the right mouse button. Figure 15: Build Target Selection Select Build Options \u0026gt; Set Active Build Spec \u0026gt; ARMARCH7\u0026lt;gnu|diab\u0026gt;. A message opens that asks if you want to set the active build spec to ARMARCH7\u0026lt;gnu|diab\u0026gt; (Figure 16).\nFigure 16: Build Target Configuration Select YES.\nBuild the project. A message opens.\nClick Continue.\nIn the bottom-left corner of the Wind River Workbench, go to Remote Systems.\nIn the window, right-click and select New \u0026gt; Connection.\nSelect Wind River VxWorks 6.x Target Server Connection, and click Next.\nType the target IP address of 192.168.1.2, and the path to the kernel image (in this case type: ..\u0026lt;project_name\u0026gt;\\default). Click Finish.\nRight-click the new connection, and click Connect.\nIn the Project Explorer window, right-click Build Targets, then select Debug VxWorks Kernel Task.\nThe Debug Configuration window opens, as shown in Figure 17 Figure 17: Debug Configuration Window From General \u0026gt; Entry, type hello to locate the hello world project. Alternatively, you can use the Browse button to find the hello world project.\nClick Debug. The terminal window that is connected to the board issue the following message:\n\u0026gt;\u0026gt; Break at 0x0144accc: hello +0x4 Task: 0x14cdfc0 (Hello) Note: The message can differ slightly from yours as it depends on your Kernel settings. It just gives you the hint that a task was downloaded and stopped for debug. In the debug window, click the Run button. The terminal window displays: Hello Wind River.\nType i to see the tasks in the VxWorks task list.\nType repeat 10,hello to repeat the task 10 times.\nAccessing a Peripheral in the Processing System # In the ARM® Cortex™ A9 processor, every peripheral is memory mapped. The address map for the Zynq-7000 AP SoC processor, for example, is listed in the Zynq-7000 AP SoC Technical Reference Manual (UG585) [Ref 2].\nModifying the Hello World Application # Modify the \u0026ldquo;Hello World\u0026rdquo; application to access the GPIO peripheral. On the ZC702 board, MIO pin 10 is connected to an LED (DS12).\nFrom the Zynq-7000 AP SoC Technical Reference Manual, (UG585) [Ref 6], you see that the base address of the GPIO peripheral is 0XE000A000. To access pin 10 as an output, you must configure this peripheral first:\nSet the direction to output by writing a 1 to bit 10 of the gpio.DIRM_0 register. Enable the output by writing a 1 to bit 10 of the gpio.OEN_0 register. Write to bit 10 of the gpio.DATA_0 register to control the LED. The updated source code of the hello world application now looks like the following:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define GPIO_BASE 0xE000A000 #define GPIO_DIRM_0 0x00000204 #define GPIO_OEN_0 0x00000208 #define GPIO_DATA_0 0x00000040 int main(void) { printf(\u0026#34;Hello World!\\n\u0026#34;); int val = 0xffffffff; sysOutLong(GPIO_BASE + GPIO_DIRM_0, 0x00000400); sysOutLong(GPIO_BASE + GPIO_OEN_0, 0x00000400); while (1) { sysOutLong(GPIO_BASE + GPIO_DATA_0, val); sleep(1); val ^= 0xffffffff; } return 0; } Save this file, then build and debug this application following steps 9 to 19 of the previous section. The result is that the LED toggles every second. Accessing a Peripheral in the Programmable Logic # Accessing a peripheral in the Programmable Logic is very similar to accessing a peripheral in the processing system: both master GP AXI interfaces have an address space of 1GB, as can be seen in the Address Map table in the Zynq-7000 AP SoC Technical Reference Manual (UG585) [Ref 6]. The differences are:\nYou must first program the PL with a BIT file containing the AXI_GPIO peripheral. You must modify the VxWorks BSP to allow access to the address range that you configured for that peripheral. The design created for this section contains an AXI_GPIO peripheral connected to the M_AXI_GP0 port of the PS.\nThe four GPIO pins of the AXI_GPIO peripheral are connected to the DS15 to DS18 LEDs on the ZC702 board.\nFigure 18: Zynq-7000 Processor System and Peripherals The Address Editor shows the base address where this peripheral is mapped, as shown in Figure 19.\nFigure 19: Address Editor After implementing this design, you generate a new FSBL, and use this FSBL, together with the generated BIT file, to create a new boot.bin file to download to the SD card.\nFollow the same steps as you used but use a slightly modified boot.bif file, as follows: //ZC702_bif_for_VxWorks: { [bootloader]fsbl.elf bitfile.bit bootROM.elf } Where:\n-fsbl.elf is the new FSBL. -bitfile.bit is the BIT created by the hardware design. This produces a new boot.bin file to boot the ZC702 board.\nTo access the peripheral from within a VxWorks kernel module, first modify the BSP. The default configuration of the VxWorks BSP configures the MMU to allow access to a limited set of addresses, listed in the documentation of the BSP.\nFigure 20: Memory Map Adding the Address Range to the MMU Configuration # The M_AXI_GP ports are not mapped.\nTo add the address range to the MMU configuration, modify the VxWorks BSP:\nOpen the VxWorks image project, then browse to the /xlns_zynq7k folder. Double-click the sysLib.c file to open the file in the Text Editor. Figure 21: MMU Configuration In the syslib.c file, scroll down to line 109, find the struct containing the MMU configuration. For example, on line 225, find the mapping for the GPIO peripheral used in the previous example: { ZYNQ7K_GPIO_BASE,/* Zynq-7000 gpio */ ZYNQ7K_GPIO_BASE, PAGE_SIZE, MMU_ATTR_VALID_MSK | MMU_ATTR_PROT_MSK | MMU_ATTR_DEVICE_SHARED_MSK, MMU_ATTR_VALID |MMU_ATTR_SUP_RWX| MMU_ATTR_DEVICE_SHARED }, Add the mapping for the AXI_GPIO peripheral by adding the following line: { 0x41200000,/* My AXI gpio */ 0x41200000, PAGE_SIZE, MMU_ATTR_VALID_MSK | MMU_ATTR_PROT_MSK | MMU_ATTR_DEVICE_SHARED_MSK, MMU_ATTR_VALID| MMU_ATTR_SUP_RWX| MMU_ATTR_DEVICE_SHARED }, Save the file, and rebuild the VxWorks project.\nUse this VxWorks image, and either:\n-Put the image on the SD card to boot from SD, or -When fetching the VxWorks image over FTP, boot the board with the updated boot.bin file. After booting the ZC702 board with this SD card, the FSBL configures the PL before launching the VxWorks BootROM. The BootROM then loads the updated VxWorks image. Updating the Hello World Project # Update the \u0026ldquo;hello world\u0026rdquo; project to access the AXI peripheral. The AXI_GPIO peripheral is slightly different from the hardened GPIO peripheral: you need only to set the direction, not enable the output driver.\nChange the contents of the file to:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #define AXI_GPIO_BASE 0x41200000 #define AXI_GPIO_TRI 0x04 #define AXI_GPIO_DATA 0x00 int main(void) { printf(\u0026#34;Hello World!\\n\u0026#34;); int val = 0; sysOutLong(AXI_GPIO_BASE + AXI_GPIO_TRI, 0); while (1) { sysOutLong(AXI_GPIO_BASE + AXI_GPIO_DATA, val); printf(\u0026#34;%d\\n\u0026#34;, val); sleep(1); val++; if (val == 0x10000) { val = 0; } return 0; } When you rebuild this project, and run it on the ZC702 board, it toggles the LEDs every second.\nConclusion # This application note has provided step-by-step instructions for running the VxWorks 6.9.3.1 BSP on the Zynq-7000 SoC All Programmable device platform, and additionally provided an overview of the boot process for the Zynq-7000 AP SoC platform.\nYou now know the steps for using VxWorks RTOS on the Zynq-7000 AP SoC platform.\nAdditional Resources # The following links are to additional resources referenced in this document:\nZynq-7000 AP SOC - Concepts, Tools and Techniques User Guide (UG837)\nZynq-7000 All Programmable SoC Software Developers Guide (UG821)\nZynq-7000 AP SoC Technical Reference Manual, (UG585)\nXilinx BSP: gppve_6_9_xlnx_zynq7k_6_9_2: https://portal.windriver.com/cgi-bin/windsurf/bsp/infoBSP.cgi?id=12020\nVxWorks 6.9.3.1 BSP Driver Source Patch: https://support.windriver.com/olsPortal/faces/maintenance/downloadDetails.jspx?contentId=041654\nVxWorks 6.9.3.1 USB L2 Cache Source Patch: https://support.windriver.com/olsPortal/faces/maintenance/downloadDetails.jspx?contentId=041575\n","date":"2024-10-05","externalUrl":null,"permalink":"/bsp/using-vxworks-bsp-with-zynq-7000-ap-soc/","section":"Board Support Package","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eThis application note has provided step-by-step instructions for running the VxWorks 6.9.3.1 BSP on the Zynq-7000 SoC All Programmable device platform, and additionally provided an overview of the boot process for the Zynq-7000 AP SoC platform.\u003c/p\u003e","title":"Using VxWorks BSP With Zynq 7000 Ap Soc","type":"bsp"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/vxworks/","section":"Tags","summary":"","title":"VxWorks","type":"tags"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/zynq-7000/","section":"Tags","summary":"","title":"Zynq-7000","type":"tags"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/series/free-training/","section":"Series","summary":"","title":"Free Training","type":"series"},{"content":" Learning Objectives # After this section you will be able to:\nUnderstand the C interpreter Understand the command interpreter Use some useful shell functions The Two Shell Modes # The kernel shell can use two modes: the C interpreter and the command interpreter. To switch between the two modes, you need to type the name of the interpreter into the shell. C for the C interpreter and cmd for the command interpreter.\n-\u0026gt; cmd [vxWorks *]# C -\u0026gt; You can also type an interpreter\u0026rsquo;s name before a command to execute a single command using that interpreter.\n-\u0026gt; cmd [vxWorks *]# C x=42 New Symbol “x” added to kernel symbol table. value = 42 = 0x2a = \u0026#39;*\u0026#39; [vxWorks *]# C -\u0026gt; The C interpreter in VxWorks # The Features of the C Interpreter # The C interpreter is a useful prototyping and debugging tool within the kernel space. Any global variable can be manipulated to: Examine the values of program variables Change the values of variables *eate new variables You can invoke almost any function in memory. When invoking a subroutine, the kernel shell passes ten arguments to the subroutine, padding with zeros if necessary. The shell prints the values of the function call (and other expressions) that it evaluates. How to Evoke the C Interpreter # Type C (upper case) to start the C interpreter.\nThe command syntax is generally the same as in the C language, as show in this example.\nVariables in the C Interpreter # The kernel shell creates new variables when a value is assigned to an undefined symbol. The interpreter looks for symbol and _symbol in the symbol table. The 32-bit VxWorks C interpreter interprets variables as 32-bit integers, whereas the 64-bit VxWorks C interpreter interprets variables as 64-bit integers. Use casts to tell the kernel shell how to interpret non-integer types. Casting is temporary – you must cast on each access. The C interpreter supports: long long type unsigned types for any values scientific notation Additional Information # The C interpreter has some syntax differences.\nYou can omit function call parentheses if the entire expression is the call. For example:\n-\u0026gt; func \u0026amp;mac, 27 not\n-\u0026gt; 2 * func \u0026amp;mac, 27 The shell does not recognize symbolic macros.\nDo not enter symbolic macros.\n-\u0026gt; sem1 = semMCreate(SEM_Q_PRIORITY) Enter\n-\u0026gt; sem1 = semMCreate(0x1) There is no support for C control structures (for, while, if, and so on) and the shell does not recognize data structures. The Command interpreter in VxWorks # The Features of the Command Interpreter # Type cmd to change to the command interpreter.\nThis provides the ability to monitor and debug RTPs. This interpreter mode is defined by a collection of commands. File commands: pwd, cat, cd Task commands: task spawn, task info, task delete Follows a UNIX-style syntax [vxWorks *]# rtp exec -s -e var=value -- cal.vxe -y Supports command aliasing [vxWorks *]# alias foo \u0026#34;task info\u0026#34; Has a special syntax for symbols [vxWorks *]# echo Address = \u0026amp;test Value = $test Command Interpreter RTP Support # This is a list of the most common commands for working with RTPs:\nLaunch help -\u0026gt; help rtp Launch an RTP -\u0026gt; rtp exec fn Show all RTPs -\u0026gt; rtp One RTP context -\u0026gt; rtp attach 0xN Show tasks in an attached RTP -\u0026gt; rtp task Command Interpreter Functionality # The command interpreter supports common shell control characters:\nPipe input and output (|) [vxWorks *]# cat file.txt | more Backquote (`) characters to evaluate a command [vxWorks *]# bp \u0026#39;expr \u0026amp;printf + 0x4\u0026#39; Redirection for input and output (\u0026gt; \u0026raquo; \u0026lt;) [vxWorks *]# cat file \u0026gt; file2 [vxWorks *]# /foo/bar/rtp.vxe \u0026lt; file2 \u0026gt;\u0026gt; file2 Useful Shell Commands # There are a few commands worth always having ready, these range from debugging, memory management, to analytics.\nDebugging Commands # The dynamic printf command or dprintf is particularly useful if it is unclear where to set breakpoints, as well as to find race conditions that are hidden when the application is stopped.\nConfigure the VxWorks INCLUDE_DEBUG component to use the C interpreter dprintf() and hdprintf() functions. Configure the VxWorks INCLUDE_DEBUG_SHELL_CMD component to use the command interpreter dprintf command. The dynamic printf command: Lets you install printf statements at run-time without having to recompile and reload applications or the kernel Can be used in both the kernel module or in RTP applications System Information Commands # Displaying system information is a valuable tool when working a project, here is a list the most common commands:\nFunction Description devs() Lists all devices known on the target system. lkup() Takes a regular expression as an argument and will list symbols from the symbol tables. lkAddr() Takes an address as a parameter and lists the symbols whose values are near the specified address. printErrno() Describes the most recent error status value. Show Commands # Show functions display useful information about the target system. Invoke them from the C interpreter of the kernel shell. They must include the associated component in the VIP.\nFor taskShow(), configure the INCLUDE_TASK_SHOW component. For memShow(), configure the INCLUDE_MEM_SHOW component. ","date":"2024-10-05","externalUrl":null,"permalink":"/training/kernel-shell-usage/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Kernel Shell Usage","type":"training"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/shell/","section":"Tags","summary":"","title":"Shell","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nUse the help feature of the kernel shell Configure a kernel shell session Kernel Shell Help Command # The kernel shell can be complicated. If you forget how to use a command, or what commands exist, you can use the help command.\nHelp Commands # Type help in the kernel shell for this list:\nAdditional Help Topics # Use these commands for other help topics:\ndbgHelp - Print debugger help info edrHelp - Print ED\u0026amp;R help info ioHelp - Print I/O utilities help info nfsHelp - Print nfs help info netHelp - Print network help info rtpHelp - Print process help info spyHelp - Print task histogrammer help info timexHelp - Print execution timer help info With that knowledge, it\u0026rsquo;s time to learn about the kernel shell configuration.\nKernel Shell Configuration # The kernel shell is not included by default. Like many other features you will need to add it to your VIP. This is to keep the initial project overhead low by not adding extra features that you might not want or need.\nThere are two ways to add the shell to your VIP: through the GUI or the CLI. Both require including the networked kernel shell or standalone kernel shell bundle. Here is how to add them:\nThe GUI Path # First, open the Kernel Configuration inside your VIP Project.\nWhen the Kernel configuration initially opens, it is set to the components view. You must switch to the bundle view in the bottom left.\nOnce in the bundle view, click on the \u0026ldquo;type filter text\u0026rdquo; and type \u0026ldquo;BUNDLE_STANDALONE_SHELL\u0026rdquo;.\nRight-click on the bundle and select \u0026ldquo;Add\u0026rdquo;. Lastly, rebuild the VIP to apply the bundle to it.\nThe CLI Path # In Workbench, right click on the VIP project and select \u0026ldquo;Open VxWorks version Development Shell\u0026rdquo;. This will open an active terminal for you to use, which opens in the VIP directory.\nIn the terminal, you will need to use the \u0026ldquo;vxprj vip bundle add BUNDLE_STANDALONE_SHELL\u0026rdquo; command to apply the bundle to the project.\nTo verify that the correct bundle has been added you can use the \u0026ldquo;vxprj vip bundle list\u0026ldquo;command.\nLastly, to see all available bundles from the CLI, use the \u0026ldquo;vxprj vip bundle list all\u0026rdquo; command .\nKernel Shell Session Configuration # The kernel shell configuration variables control various settings in a shell session. These variables can be updated statically or dynamically.\nSome of these variables are:\nINTERPRETER identifies the interpreter, either C (default) or command LINE_EDIT_MODE sets the line edit mode, either vi (default) or Emacs LINE_LENGTH sets the shell line length (default is 256 characters) Updating the configuration variables dynamically depends on the interpreter you are using.\nThe shConfig() function with the C interpreter The set config command with the command interpreter ","date":"2024-10-05","externalUrl":null,"permalink":"/training/kernel-shell-configuration-and-commands/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Kernel Shell Configuration and Commands","type":"training"},{"content":" Learning Objectives # After this section you will be able to:\nUse the VI editor Describe and implement the object-module loader The kernel shell makes use of command line editors, this is a quick guide on their functionality.\nCommand Line Editing # The kernel shell supports the VI editor as its primary editor and emacs as a secondary editor. While working in the shell, it will store commands in a history list with a maximum length of 20 commands. The shell supports command-line completion.\nNavigating in VI # To start working with the VI editor, you need to press ESC to enter line-editing mode. Here is a list of those commands.\nk - Backwards through history buffer j - Forwards through history buffer h - Move cursor to the left l - Move cursor to the right a - Append after cursor A - Append at end of line i - Insert before cursor I - Insert at beginning of line rc - Replace current character with character c x - Delete current character dd - Delete entire line nG - Go to history line /string Search for string Command-Line Completion # Mentioned before, the shell supports command autocompletion. To perform this, use the following commands:\nCTRL+D - To list symbols CTRL+D, TAB - To list and autocomplete symbols or file names Emacs mode # To enable emacs use the following command:\nshConfig \u0026#34;LINE_EDIT_MODE=emacs\u0026#34; As a note, emacs can do a lot more than the Vi editor but has much more overhead. This is why VI is the primary by default.\nCommand History Limit # Lastly you can modify the command line history with the h() function. This can increases the default of 20 all the way to 500 if you use h 500, for example.\nThat covers the text editors that VxWorks uses. Next you will be learning about the object module loader.\nObject-Module Loader # The object-module loader interacts with the kernel to load or unload code at runtime. This is useful during project development because it lets you unload, recompile, and then reload the object-modules that are being developed.\nThe alternative is to link the development code to a VIP. In this case, every time you want recompile that code you will have to rebuild the VIP and reboot the target.\nTo use an object module loader, first configure your VIP to include the component: INCLUDE_LOADER.\nThe loader must have access to the symbol table, as the object-module relies on information from it.\nAfter the project has been configured you have access to two new functions. The first is ld() which lets you load C interpreter commands and unld() which unloads C interpreter commands.\nThe object-module loader lets you dynamically expand VxWorks. When code is loaded onto the OS, it makes no distinction between the original image and the new module loaded in.\nLastly the object-module loader allows for the handling of memory allocation. This happens on a per-load basis and for modules that are downloaded.\nThis has two applications. First, to dynamically allocate memory for downloaded code and free that memory when an unload is called. Second, the caller can specify the addresses of memory that have already been allocated. This allows you to have more control over the layout of the code in memory.\nDo not unload an object-module while its tasks are still running, this may result in unexpected ways. ","date":"2024-10-05","externalUrl":null,"permalink":"/training/command-line-editing-and-object-module-loader/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Command Line Editing and Object Module Loader","type":"training"},{"content":" Learning Objectives # After this section you will be able to:\nDescribe the functionality of the VxWorks kernel shell Use basic cross-development commands Understand the kernel shell functionality The kernel shell is a powerful tool that can be used for development, debugging, and deployment of a VxWorks project.\nWith the concept of the VxWorks kernel shell established, you will now learn how to development with it.\nCross Development Using the Kernel Shell # The kernel shell is able to use both the C interpreter and command interpreter. This allows you to write C code straight into the Shell and work with the commands provided.\nDownload and link object files -\u0026gt; ld \u0026lt; anagram.o Run functions -\u0026gt; printf (\u0026#34;hello\\n\u0026#34;) Spawn new tasks -\u0026gt; sp (logMsg, \u0026#34;error\\n\u0026#34;) Debug code at the assembly level -\u0026gt; b printf Display target state information -\u0026gt; i Using the kernel shell is a powerful option in a VxWorks project. It provides functionality for making and maintaining your project.\nThe Kernel Shell Functionality # Target-Field Tool Functionality # The target-field tools are useful for field maintenance. These tools provide the following functionalities and benefits:\nIdeal for early board support package (BSP) and driver development before the network is up Useful for debugging a deployed system over a serial connection Useful for developing and debugging network protocols Can be used to load kernel modules from a target disk or over the network and run them interactively Provide C functions as built-in commands (see usrLib.c) Provide security Support Telnet and rlogin access Additional Functionality # The kernel shell provides a few other functionalities and features:\nVxWork 5.5 and 6.x compatibility mode Symbol completion, limited to some file systems (NFS, local, and PassFS) Inactivity timeout of the shell session Configurable shell line length Target-resident show functions are also available to examine object information Kernel Shell Resource Overhead # Adding the kernel shell requires adding additional code to the kernel build image and requires that the symbol table resides on the target you are connecting to. This will substantially increase the overall footprint of your project. This includes a collection of target-resident tool libraries:\nloadLib unldLib shellLib usrLib dbgLib ","date":"2024-10-05","externalUrl":null,"permalink":"/training/introduction-to-the-kernel-shell/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Introduction to the Kernel Shell","type":"training"},{"content":" Learning Objectives # After this section you will be able to:\nConfigure application projects Import and export projects Build a project Configuring and setting up the VSB and VIP is known as platform development. The next step for your project is application development.\nCreating Application Builds # Application development consists of creating features for your project. During project creation, you have a few different application project types to choose from. The available project types are:\nUser space applications, known as real-time processes (RTPs) Shared libraries Downloadable kernel modules (DKMs) CMake RTPs and CMake DKMs In the list above you can see there are two versions of RTP and DKM. This is because they can make use of makefile-based projects. If the CMake option is chosen, the developer defines the build structure and writes the makefile for the project.\nThe alternative is that there is no build type. This makes it so you have platform-specific environment for static analysis. You also have the ability to disable the build.\nCreating Application Builds # When making a new application build you have two choices for where to make the project:\nCreate a project in your workspace: Create the project folder Store the settings in the project Create a project at an external location: Supports source control scenarios All source and settings are under source control The source tree is not contaminated with build output files. New Project: RTP # When making the RTP you must base the project on one of the following:\nA VSB A VIP An existing DKM project Since the VSB is the root of the project, the RTP inherits the build specifications from it. The build target for the RTP looks for executable objects by default, which are:\nVXE extensions Fully linked or linked against shared libraries New Project: DKM # Creating a DKM uses the same method as an RTP project. The DKM can use the default build settings or inherit them from another project. You can always modify the build command later.\nAdding Build Targets # When working on your project you can add build targets to it. You can create an unlimited number of them, just note that one build target will generate one binary. You can customize the source contents for each target along with modifying the build tools.\nIf you do not specify a build target, no initial build target will be created.\nManaging files and folders in Workbench # Now that you have the project types set up, your VSB, VIP, maybe the RTP and DKM. You will want to add some files to them to start development and adding folders to keep the project organized.\nChoosing a new file or folder While in Workbench, you can right click in the Project Explorer to open a drop-down menu. Go the tab that says New, this will show you the different file choices.\nPicking a New File Making a new file is simple, you pick the template you want or start from a blank file. The defaults you can choose are:\nFile (Blank File) File from Template Class Header File Source File When you make a new file, you can make it directly inside of a project. During creation you have a few options, the first is picking a local name, or create and use a path variable for the file. Once you decided that you can also use the Advanced option to link it to existing files.\nAdding Folders to Projects Folders are much simpler than files, when you go to create one you only have two choices:\nFolder (Default) Source Folder When you pick the option, you will create a name and chose which project type it will be a part of. Then it will appear in the project structure ready for use.\nExcluding Files and Folders from a Build When working on your project you might want to exclude a file or folder without deleting them, you can do this in Workbench and do it for each build target. To exclude them, right-click the file or folder under the desired build target and select Edit Excludes.\nThe example above uses a DKM named myDKM. With a configured project, you can share it or load it onto your system with importing a exporting.\nExporting and Importing Projects in Workbench # Exporting and importing projects is a time saver and is a valuable skill in Workbench. Exporting is taking your project and archiving it so that Workbench can read it at a later time. Importing is taking the archive you made or someone else made and adding it to your project. Take a look at the features below:\nExport Features # Right-click a project and select Export. Files, settings, and breakpoints export directly to other projects or to *.zip and *.tar files. Use *.zip and *.tar files to copy or email project files off-system. You can export the settings and files to pass them from one project to another project on the same system. Import Features # Select File \u0026gt; Import. Importing a project copies its existing items into the workspace. The resources of an existing project within the present workspace are referenced (not copied). Selected file systems or archive files are copied into the existing project. Breakpoints are included. Import a team project set that was previously defined and exported. Building a VxWorks Project # When we show up to the present moment with all of our senses, we invite the world to fill us with joy. The pains of the past are behind us. The future has yet to unfold. But the now is full of beauty simply waiting for our attention.\nBuild Properties # When configuring your project, you will need to add build properties to it. There are three main components to the build properties:\nProject-specific build targets A set of build tools, build macros, and build specs suited to the project type The make command and a makefile Workbench has predefined settings for specific builds, these include user applications, shared libraries, kernel objects, or OS images. You can change the predefined settings in the project properties, but the settings and values depend on the project type.\nTo build the project, right-click the project in the Project Explorer to bring up the menu. Here you have two choices:\nBuild Project- This is the default build type. This is recursively build all selected projects as a subproject of the VSB. If it\u0026rsquo;s the VSB then it will just compile it normally. Rebuild Project- Rebuilding will clean the project before doing a standard build. Clean is a process where VxWorks will delete all the libraries first to have a fresh start. Some notable commands in this drop down also include:\nOpen VxWorks version Development Shell- This will open the VxWorks shell in the project space you selected. Refresh- When you refresh a project it will update any files that have not registered changes yet. Close Project- Closing the project will remove all the files from Workbench but leave the root folder for the project. When you open the project, it will repopulate the files back. In the Build menu you have two options to build from, these are:\nClean Project- This will remove all the object files and any archived files in the project. This is used before checking a project into source control. Build Enabled Build Specs- This will allow you to build to a custom build spec that you provide the project. In this menu you can change the active build spec with Set Active Build Spec\u0026hellip; and manage it too with Manage Active Build Specs\u0026hellip;\nThat covers how to build a project! This is great but there is one more important thing to discuss, what happens when the build fails?\nBuild Output and Errors # When a build fails in Workbench, it ends. This will display in the Build Console with a detailed message about why the build failed. This can be logged and saved as output. To go to the error, double click it in the Build Console to open the Editor View.\nWhen an error occurs, it will be highlighted red in three locations, the build console with a detailed message, the line number of the error in the afflicted file, and lastly in the Project Explorer next to the file.\nThis error is caused by a missing semicolon on line 482. ","date":"2024-10-05","externalUrl":null,"permalink":"/training/configuring-and-building-a-project/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Configuring and Building a Project","type":"training"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/vip/","section":"Tags","summary":"","title":"VIP","type":"tags"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/vsb/","section":"Tags","summary":"","title":"VSB","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nDescribe a ROMFS Create and link a ROMFS to a VIP You learned about the file system and different project type in this course already. This section discuss the next step, the VxWorks ROMFS.\nOverview of ROMFS # ROMFS stands for read-only memory file system. The ROMFS sits on the top of the VxWorks memory layout. It is part of the kernel heap memory and is initialized during startup. Having a ROMFS is optional. It provides a secure run-time storage solution.\nThe ROMFS provides a RAM drive to store files. This works by statically adding files to the OS in an object called content.romfs. This object is linked to the text section of VxWorks.\nSince ROMFS is an optional feature, it requires additional build configuration.\nApplying the build configuration # To configure and add a ROMFS to your project, add the following in your project to utilize ROMFS.\nAdd the FS and FS_ROMFS VSB options Add the INCLUDE ROMFS VIP component With the VSB and VIP configured, you can create the ROMFS. This guide explains how to add a ROMFS to your VxWorks project.\nCreating the ROMFS # To make a ROMFS, follow the normal project creation workflow:\nSelect File \u0026gt; New \u0026gt; Wind River Workbench Project. Select Platform Development in Based on Category. Select ROMFS File System in Build Type. Creating the ROMFS (Cont\u0026rsquo;d) # Once you have selected the project type, you will be asked to name the project and select its location. You can choose to create it in the workspace, in an external location, or in the workspace with content in an external location.\nEditing ROMFS Contents # The ROMFS has now been created. You can open it and start to add content to the file system. A common list of files to add to a ROMFS are:\nRTPs Shared libraries Text or data files *.o files You can add files from the current host workspace or from external location. Associate a ROMFS with a VIP # Lastly, you can make a ROMFS into a sub-project to a VIP. To attach them together, drag and drop the ROMFS project under the VIP in the Project Explorer view. This will automatically link the ROMFS to the VxWorks kernel image. Once connected you can find the contents of the ROMFS under the /romfs directory in the target.\nFor more information refer to VxWorks File Systems and I/O Programmer\u0026rsquo;s Guide ","date":"2024-10-05","externalUrl":null,"permalink":"/training/read-only-memory-file-system/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Read Only Memory File System","type":"training"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/romfs/","section":"Tags","summary":"","title":"ROMFS","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nApply vxprj commands to your projects Import a project made with vxprj into workbench Overview of the vxprj Utility # VxWorks provides the vxprj utility to create, manage, and build VxWorks projects. It is accessible through the command-line interface (CLI) and can be launched inside and outside Workbench. In the case of using it externally, you must import the project into Workbench.\nThis section will contain multiple code blocks showing the results of using vxprj commands.\nGetting Help for vxprj # Vxprj has multiple help commands that cover all of its utilities. This short guide will show you how to use the most common ones.\nTo view the vxprj command groups and general help commands, type vxprj help (or just vxprj). To get help with project commands, type vxprj project help To get help for a specific subcommand, type vxprj project subcommand help It\u0026rsquo;s time to learn about how to manage your project with vxprj. # Managing Projects with the vxprj Utility # In this section, you\u0026rsquo;ll examine some example commands that you can use with the vxprj utility. In the next few examples, the project will have a VSB called myVSB, a VIP called myVIP, and lastly it will use the board xlnx_zynqmp_3_0_0_1.\nYou can create a project with the vxprj project create commands. You can configure VSB options with the vxprj vxb config commands. You can configure VIP components with the vxprj vip component add command. You can build a project with the vxprj project build commands. To see a list of valid BSPs, execute the vxprj vsb listBsps command. To see a list of valid CPUs, execute the vxprj vsb listCpus command. Lastly, if you use vxprj externally you will need to import the project into Workbench. This section will explain that process.\n","date":"2024-10-05","externalUrl":null,"permalink":"/training/the-vxprj-utility/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"The Vxprj Utility","type":"training"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/vxprj/","section":"Tags","summary":"","title":"Vxprj","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nCreate a VSB Create a VIP Understand the different configuration options for a VSB and VIP The center of every VxWorks project is the VxWorks source build and image projects. The VSB and VIP have a variety of customization options to suit any project type. VSB configuration options # The VSB project facility provides an extensive set of options that you can select to configure a VSB project.\nBSP-specific optimizations (such as floating-point support) System Viewer instrumentation Real-time processes Object management Symmetric multiprocessor (SMP) Debug mode Advanced options Parallel Builds # The parallel builds feature uses Make to create extra threads of execution and invoke the compiler or other build rules in those extra threads.\nThis process makes use of both RAM and the CPU, and relies on the Symmetric Multiprocessor scheduler.\nThis option can be disable in the build console as it can consume a lot of system resources.\nVIP Standard Profile Options # During the last step of creating a VIP you must select a configuration profile. These will add or remove kernel libraries from the image, giving you a quick starting point.\nPROFILE_BOOTAPP # This profile adds RAM-based bootloader functionality to a standard VxWorks image.\nPROFILE_BOOTROM # This profile adds ROM-based bootloader functionality to a standard VxWorks image.\nPROFILE_DEVELOPMENT # This profile adds development and debugging components to the VxWorks image.\nPROFILE_HARDENED # This profile will configure a VxWorks kernel image with security-hardened features.\nPROFILE_MINIMAL # This profile will tune the configuration with the goal of producing the smallest possible VxWorks kernel image.\nIn VxWorks you might see the term STANDALONE referring to a profile, a library, and more. This term means that the project is embedded and does not need a network connection to run. ","date":"2024-10-05","externalUrl":null,"permalink":"/training/vxworks-source-build-and-image-projects/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"VxWorks Source Build and Image Projects","type":"training"},{"content":"","date":"2024-10-05","externalUrl":null,"permalink":"/tags/layer/","section":"Tags","summary":"","title":"Layer","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nNavigate the VxWorks file directory Understand what a layer is and its role in VxWorks File hygiene is important on any project, so it is important to know where everything is. This section will guide you through the VxWorks file system.\nThe Journey through the file system # Step by step to learn about the VxWorks file structure.\nTop of the Installation Directory # The top-level directory of your installation contains:\n3pp-download/ compilers/ download/ etc/ legal-notices/ license/ maintenance/ readme/ setup/ utilities/ vxworks/ workbench-4/ Compilers # This directory contains the compilers installed with your VxWorks. Third party compilers are supported and would be installed here too. By default, it has two:\nlvm Rust VxWorks supports multiple versions of the same compiler, so if errors are encountered, you can easily revert to the old compiler.\nFor details on how to port a third-party compiler, refer to the VxWorks Configuration and Build Guide.\nMiscellaneous Directories # The top-level directory of your installation contains the following subdirectories for miscellaneous purposes:\netc/ contains installation configurations license/ contains user license files maintenance/ contains the Wind River installer utility utilities/ contains various important binary utilities used by Workbench setup/ contains product installation scripts workbench-4 Directory # In this directory you will find all the files pertaining to the Workbench IDE. Some notable paths from here are:\nSamples- This gives an example project for each of the VxWorks project types. Simulator and Simics- These contain the files for the VxWorks simulator and the Simics simulator. startWorkbench.bat- This is a startup script to launch Workbench. vxworks Directory # This is the VxWorks release directory. In this course it is 22.06 but yours may be different. It can be found at vxworks/release, this directory contains the following subdirectories:\ndocs/ contains product documentation host/ contains development host utilities man/ contains API references samples/ contains example and prebuilt projects source Directory # Within the source directory you will find all the components that VxWorks uses to build the VSB. It can be found in vxworks/release/source and contain the following subdirectories:\nboot/ contains boot loader technology (such as BIOS, UEFI, and VxBL) build/ contains makefiles and build rules contrib/ contains third-party layers features/ contains feature CDF files installset_data/ contains a list of installed layers, BSPs, architectures, and compilers os/ contains the VxWorks kernel layers VxWorks Layers Directory # The Layers directory contains VxWorks libraries and components. The directory is located at vxworks/release/source/os and contains the following subdirectories:\narch/ contains architecture layers connectivity/ contains USB, FireWire, Bluetooth, and other layers container/ contains container runtime and management layers multimedia/ contains UI layers net/ contains the network stack security/ contains OpenSSL, crypto, and others storage/ contains file systems Board Support Packages Directories # The BSP directory is located at vxworks/release/source/os/arch.\nBSPs are categorized by their architecture (Arm, Intel, PowerPC, or RISC-V) and, in the subsequent board directory, their silicon vendor.\nThe Git Directory # By default, the VxWorks installer installs the kernel source code in a Git directory. The Git directory let you perform source code management on the VxWorks source code, such as:\nCommits Branches The use of remote Git Repositories You do not need these source code management actives to build or use VxWorks. In essence, the kernel source code Git directory acts as a traditional, unmanaged file system directory.\nYou can also disable the Git option. In that case, the installer deploys the kernel sources as an unmanaged install tree directory.\nSummary # Now that you have seen where all the different directories are located, take a look through them. Many projects require third-party plug-ins and custom libraries, and now you are equipped with navigating them.\nWith VxWorks, you can customize a feature... through layers. Layers deliver features that a VSB project can build into VxWorks libraries. Inside and Outside Layers # Inside Layer # An inside layer is located in the Wind River install directory, at installDir/vxworks/release/source/os/. All layers provided by Wind River are considered inside layers, and many custom layers are too.\nOutside Layer # Outside layers are created and saved outside of the Wind River installation directory. As an example, board venders who write drivers or BSPs may want to deliver their software without modifying the install directory of VxWorks.\nThe workflow to create, use, and share custom inside or outside layers is as follows:\nCreate a layer on a workstation. Add the layer to a VSB and test it with a VIP. Export the layer in an RPM. Import the layer RPM on another workstation containing a fresh VxWorks installation. ","date":"2024-10-05","externalUrl":null,"permalink":"/training/vxworks-directory-structure-and-package-management/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"VxWorks Directory Structure and Package Management","type":"training"},{"content":" Learning Objectives # After this section you will be able to:\nDescribe the benefits of Wind River Projects Describe role of the workspace Describe the different VxWorks project types Targets and connections are the hardware side of a VxWorks project. The software side are the VxWorks project types and workspaces.\nWhat are VxWorks projects and workspaces # VxWorks projects are a collection of project types that operate different aspects of a real-time system. This includes kernel image, libraries of code, operating both the user space and the kernel space, and where all the files are stored in a VxWorks project.\nThe different VxWorks project types # There are four main categories of project types in VxWorks, here is a summary of each:\nVxWorks source build (VSB) # The VSB is the heart of a VxWorks project. This is the main project type you will make and link all other project types to it. The VSB manages:\nThe VxWorks kernel libraries The BSP or CPU types Which layer version you want to deploy VxWorks image project (VIP) # The VIP is required to launch VxWorks in an embedded system. The VIP makes a kernel image in binary that can be read and deployed by the bootloaders. The features of the VIP include:\nBeing based on a VSB or another existing VIP Being able to modify tool flags, build macros, paths, and other specifications Kernel configuration profiles, including bootApp Application projects # Application projects consist of three main types: real-time processes (RTP), shared libraries, and downloadable kernel modules (DKM). You are able to add multiple build targets and edit source file contents in these project types.\nReal-time processes- RTPs are used in user memory space. This means that an RTP can only use system resources that are directly assigned to it, creating a buffer between it and the kernel. RTPs are useful when you don\u0026rsquo;t want the application to interfere with another application in the project. Shared libraries- The shared libraries are a useful project type as they let you share parts of or a full RTP on the system. This lowers the memory footprint and allows for the reusing of methods. Downloadable-kernel module- The DKM runs in the kernel space. This allows it to have full access to system resources, making them highly flexible. This extra flexibility can be dangerous, so using malloc and semaphores are important. Makefile-based projects # Makefile projects are automated project types. You mus define their build structure and create their makefile. It can speed up the development of a project by automatically setting system parameters. The makefile project type parallels the other application project types, just with the added make features.\nThere is also a toggle to turn off the makefile for the build in case you want to manually run the project.\nTop-down perspective of the VxWorks project types # ","date":"2024-10-04","externalUrl":null,"permalink":"/training/introduction-to-projects-and-workspaces/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Introduction to Projects and Workspaces","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/project/","section":"Tags","summary":"","title":"Project","type":"tags"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/workspaces/","section":"Tags","summary":"","title":"Workspaces","type":"tags"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/qemu/","section":"Tags","summary":"","title":"QEMU","type":"tags"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/simics/","section":"Tags","summary":"","title":"Simics","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nIdentify the different simulator options for VxWorks There are many challenges when developing a real-time embedded project, but the hardware does not have to be one of them. Hardware simulation can be used to simulate all of the individual components of a board.\nVxWorks and Simulators # When working on a project, you might want to be able to test something without the target board present. This might occur because multiple developers are sharing one board, or the board is still in development and you want to start coding. Simulators allow for the target board to be recreated in software, giving real results to what the board would give.\nVxWorks provides you with options for simulators to be used with your project. Choosing one that works best at each phase of the development is key. Expand each section below to learn more about the different simulators available with VxWorks.\nVxWorks Simulator (VxSim) # VxSim is an OS simulator with no deterministic behaviors. It does not act like a processor or target board, so its main use is for early application development.\nVxSim is lightweight and easy to implement in workbench. It allows for work to get started early in a project but will need to be phased out once you start to add processor-specific code or start to qualify the code behavior.\nThe QEMU Simulator # QEMU is an open-source process simulator that supports a variety of target boards. It will simulate the board support package for the host OS, which allows it to become a target based on the underlying host\u0026rsquo;s architecture. QEMU creates the same development environment as a hardware target, allowing a user to write processor-specific code.\nUsing QEMU allows for prototyping and development before the hardware is available.\nSimics Simulator # Simics© is a true hardware simulator. This means that it can simulate the CPU, an entire board, or a system of multiple boards. This allows for Simics to interact with Workbench the same way that a hardware target would.\nSimics allows you to write instruction-accurate code, meaning software development before the hardware is fully available. Simics also offers powerful analysis tools such as trace, reverse execution, fault injection, and simulation checkpoints.\n","date":"2024-10-04","externalUrl":null,"permalink":"/training/simulation-overview/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Simulation Overview","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/simulator/","section":"Tags","summary":"","title":"Simulator","type":"tags"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/vxsim/","section":"Tags","summary":"","title":"VxSim","type":"tags"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/workbench/","section":"Tags","summary":"","title":"Workbench","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nDescribe the TCF agent and its role in a VxWorks project Set up a connection with the target in Workbench Wind River, along with other developers, have been working on an open-source project for establishing connection with an embedded system. The network protocol is called the Target Communication Framework or TCF.\nCreating a Connection # This is a detailed walk-through on how to make a connection in Workbench and the different features provided.\nThe Connection Box # When you open Workbench, you will see the \u0026ldquo;New Connection\u0026hellip;\u0026rdquo; box in the top left corner. This is where you will find any connections you have made in workbench. You can also modify or delete them.\nTarget Types in New Connection # When you click on the box it will open with a few choices.\nRunning Target- If you have a physical target present, this option allows you to plug it into your host and start testing. Core Dump- This will allow you to analyze an image of a previously run VxWorks system. Its a snapshot of the system, when the core file was dumped. QEMU- This creates a local instance of the QEMU simulator. VxWorks Simulator- This creates a local instance of the VxWorks Simulator or VxSim for short. Note: Advanced Simulation Platform was removed as of VxWorks 23.09\nConfiguration in New Connection # The configuration depends on the target type you are working with. For example, the VxWorks simulator only requires the kernel image. You can find this where you have saved your VxWorks project.\n##Connection is Made\nAfter the connection is made, you will notice a few things change.\nThe connection symbol has one grayed out symbol and one red symbol. This is how you terminate your connection to the target. Red is to terminate the connection and green is to connect to the target.\nThe analysis actions become available. These tools are only accessible when connected to the target. Here you will find tools such as the Memory Analyzer or the CPU profiler. They will help you analyze and debug aspects of your project.\nChoosing the Target # Now that you have seen all the options for connecting to a target, you can choose what works best for your project\u0026rsquo;s needs. The connection type can change during development so be aware of which one is the most useful at any given time.\n","date":"2024-10-04","externalUrl":null,"permalink":"/training/workbench-tools-architecture/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Workbench Tools Architecture","type":"training"},{"content":" Learning Objectives # After this section you will be able to:\nExplain how VxWorks boots Use the VxBL and BootApp commands To start working with the hardware in a VxWorks project you need to deploy a kernel image to it.\nHow does a target boot # When you write the code for a target in Workbench you are modifying the kernel image, but how do you deploy the kernel image? You must use a bootloader. This is code that deploys the kernel image and then executes the startup sequence for the kernel.\nVxWorks supports a variety of boot strategies, many of which are board specific.\nFor board-specific information, see the readme.md file in your BSP directory. installDir/vxworks/release/source/os/arch All BSPs start in this directory, find the CPU architecture that you are using and then choose the board vendor. VxWorks primarily operates with a two-stage bootloader model. Follow the image below to see how this model interacts with the system.\nPower On This is the power signal going to the target.\nStage 1 bootloader In this example VxBL launches but it can be any stage 1 bootloader. You might see this stage be referred to as BootStrap code.\nPhysical Storage This is the physical storage you want to use to launch the bootloader. This can be Flash memory, SD card, SSD, HDD or some other physical drive.\nStage 2 Bootloader A stage 2 bootloader requires a stage 1 bootloader to help get things started. The stage 2 is able to do more heavy lifting since it\u0026rsquo;s not limited to space on a drive for its code, just the memory on the target.\nNetwork Connection A stage 2 bootloader can use the network that it is connected to help launch the kernel image. This can be from a File Transfer Protocol (FTP) or a Network File System (NFS) server.\nThe Kernel Image After the bootloaders do their magic, the kernel image is launched. Your VxWorks project is now running!\nROM or System? When VxWorks launches and it needs to initialize the code, it can either use a romInit or a sysInit. ROM or read only memory is used when you need to boot the system rapidly. SysInit is the default initialization mode.\nTo make full use of the VxBL and the BootApp, examine their commands in the chart below. VxBL Commands # When running VxBL, if you ever need the list of commands type help in the terminal.\nHere is a list of the commands for reference:\nfdt - perform device tree operations: fdt env - perform environmental variable operations ls - list directory content pwd - get current working directory: pwd cd - change current working directory: cd load - load file content to memory: load boot - boot kernel: boot - pm - show persistent memory area help - print help message @ - boot kernel using pre-defined scripts d - display address content BootApp Commands # When running bootApp, if you ever need the list of commands type h in the terminal.\nHere is a list of the commands for reference:\n? - print this list @ - boot (load and go) p - print boot params c - change boot params l - load boot file g adrs - go to adrs e - print fatal exception v - print boot logo with version d adrs[,n] - display memory m adrs - modify memory f adrs, nbytes, value - fill memory t adrs, adrs, nbytes - copy memory For more information on the non-Wind River bootloaders refer to the Wind River documentation site. Wind River Documentation ","date":"2024-10-04","externalUrl":null,"permalink":"/training/booting-a-hardware-target/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Booting a Hardware Target","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/bootrom/","section":"Tags","summary":"","title":"Bootrom","type":"tags"},{"content":" Learning Objectives # After this section you will be able to:\nDefine what a host and target are. Explain how a connection is made between the host and target. Describe how to configure the target hardware. All VxWorks projects are different, but they all require hardware configuration.\nConfiguring the Hardware # You have already learned that VxWorks is a real-time operating system but how do you develop with the OS? I\u0026rsquo;ll show you how to configure and set up a connection from a host to a target.\nWhen you are configuring your hardware, it is important to ensure compatibility between the CPU and the target board.\nHere are a few examples of what the board and CPU combinations might look like:\nBoard: xlnx_zynqmp_3_0_0_1 CPU: ARMARCH8A Board: fsl_p1p2_4_0_0_1 CPU: PPCE500V2 Board: ti_sitara_a15_3_0_0_1 CPU: CORTEX_A15 ","date":"2024-10-04","externalUrl":null,"permalink":"/training/hardware-target-configuration/","section":"Free Training","summary":"\u003ch1 class=\"relative group\"\u003eLearning Objectives \n    \u003cdiv id=\"learning-objectives\" class=\"anchor\"\u003e\u003c/div\u003e\n    \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#learning-objectives\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\n    \u003c/span\u003e        \n    \n\u003c/h1\u003e\n\u003cp\u003eAfter this section you will be able to:\u003c/p\u003e","title":"Hardware Target Configuration","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/target/","section":"Tags","summary":"","title":"Target","type":"tags"},{"content":" VxWorks The Leading RTOS The industry's most widely deployed RTOS. VxWorks has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\nWhy VxWorks ? # Real-time embedded systems need a robust real-time operating system (RTOS) that leverages the latest and greatest enhancements in processor and hardware technology.\nVxWorks RTOS is the industry leading real-time operating system (RTOS). For more than 35 years, the VxWorks® real-time operating system (RTOS) has been chosen by global industry leaders as the trusted foundation to power billions of safety-critical intelligent devices, machines, and systems. Its rich functionality helps customers deploy innovative products while lowering costs and shortening production cycles.\nWhy is VxWorks the RTOS for your next project ? # Key characteristic of VxWorks # Proven: VxWorks is the RTOS that powers more than 1 billion real-time systems across the globe, from small consumer products to commercial airliners. When the consequences for failure are expensive or, worse, life threatening, the VxWorks RTOS is the only choice. After 30 years of RTOS leadership and consistently successful deployments, Wind River is the name you know you can trust.\nOptimised: The VxWorks RTOS has been optimised for performance, determinism, and code footprint on each processor platform it runs on. The VxWorks RTOS is also optimised for specialised hardware support for such features as network acceleration and graphics. Why waste processing power on a non-optimised RTOS?\nInnovative: The first RTOS with 32-bit and 64-bit processing, multi-core and multi-OS support, and diverse connectivity options, VxWorks provides our customers with the leading-edge RTOS functionality they require to stay competitive. Why go with an RTOS that doesn’t provide the solutions you need to take advantage of the latest technology?\nUnparalleled Innovation # VxWorks drives RTOS innovation in key requirement areas for embedded systems. By their very nature, embedded systems are constrained by memory, performance, and power consumption. Application requirements continuously grow to satisfy new safety and security standards and customer value criteria such as rich user interfaces and connectivity. VxWorks meets these growing requirements with unparalleled RTOS innovation:\nMulti-core/multi-OS: VxWorks is designed for use in various multi-core configurations as a single operating system in symmetrical multiprocessing (SMP) and asymmetrical multiprocessing (AMP) modes or as a guest RTOS on top of Wind River Hypervisor.\nScalability: VxWorks offers robust and reliable RTOS performance on small memory- and CPU-constrained devices up to full 64-bit multi-core systems for high-end processing. Because of this scalability, VxWorks is the ideal RTOS for creating a common software platform for a product line of embedded devices.\nSecurity and safety: Our leadership in safe and secure systems includes a certifiable RTOS for very stringent safety standards such as FAA/RTCA DO-178B/EUROCAE ED-12B Level A, IEC 61508, and ARINC 653. VxWorks also provides a multilevel secure (MLS), High Robustness RTOS for the demanding requirements of the Common Criteria and National Information Assurance Partnership (NIAP). VxWorks is the first RTOS to be certified under Wurldtech’s Achilles certification program, an internationally recognized standard for industrial cyber-security.\nConnectivity: VxWorks provides industry-leading advanced networking solutions for every facet of embedded systems communications, from device to device via USB, and core to core in an AMP multi-core system with MIPC.\nGraphics: VxWorks RTOS and Wind River Media Library form a robust platform for embedded graphics solutions. With Wind River Tilcon Graphics Suite, developers have a complete graphical user interface (GUI) development system for next-generation devices.\nSignificant Strengths # At Wind River, we take pride in the innovations in VxWorks that have made it the No. 1 RTOS in the world, and we’re committed to continued innovation in each of our core strength areas:\nFootprint: VxWorks has a completely configurable and tunable small memory footprint for today’s memory-constrained systems. You control how much of the operating system you need.\nReal-time performance: Capable of dealing with the most demanding time constraints, VxWorks is a high-performance RTOS tuned for both determinism and responsiveness.\nReliability: A high-reliability RTOS, VxWorks provides certification evidence required by strict security standards. Even for non-safety-critical systems, VxWorks is counted on to run forever, error free.\nScalability: An indispensable RTOS foundation for very small-scale devices, large-scale networking systems, and everything in between, VxWorks is the first RTOS to provide full 64-bit processing to support the ever growing data requirements for embedded real-time systems. VxWorks is scalable in terms of memory footprint and functionality; you will tune it to the exact needs of your project.\nVxWorks Industry Specific Profiles # VxWorks delivers a rich set of features out of the box, so customers can more quickly and efficiently build breakthrough devices for the Internet of Things (IoT). Optional industry and technology add-on profiles enhance VxWorks with a broad assortment of capabilities that help our customers meet technology and certification requirements specific to their industry.\nVxWorks Technology Specific Profiles # VxWorks add-on technology profiles facilitate rapid development of unique features and capabilities necessary for specialised applications.\nVxWorks Certified Platforms # VxWorks safe and secure platforms deliver the foundation companies need to address the security and safety aspects of critical applications, including certification evidence required for stringent certifications by standards bodies:\nWind River VxWorks 653 Platform delivers complete ARINC 653 Part 1, Supplement 2 conformance and expands the ARINC 653 XML configuration capabilities to enable a true multi-vendor platform that supports fully independent RTCA DO-297/EUROCAE ED-124 IMA supplier sourcing.\nWind River VxWorks Cert Platform provides a proven safety critical software development environment for delivering applications that must be certified to the requirements of RTCA DO-178B or IEC 61508 (functional safety of electrical/electronic/programmable electronic safety-related systems [E/E/PES]) and related safety critical software standards. Complete certification evidence is provided for DO-178B and IEC 61508.\nWind River VxWorks MILS Platform delivers the security foundation aerospace and defense companies need to meet the real-time operating system requirements for high robustness (EAL6+) multilevel secure systems.\nVxWorks – Architecture / Processor Family Support # Intel MIPS ARM PowerPC Pentium family MIPS 4Kx ARM7 PowerPC 40x Xeon MIPS 5Kx ARM9 PowerPC 44x Xeon LV MIPS 24Kx ARM11 PowerPC 60x Core MIPS 34Kx ARM11 MPCore PowerPC 7xx Core 2 Duo MIPS 74Kx ARM Cortex A8 PowerPC 74xx Atom Cavium OCTEON CN3XXX ARM Cortex A9 MPCore PowerPC 83xx Cavium OCTEON Plus CN5XXX PowerPC 85xx, 8572 Cavium OCTEON Plus CN63XX PowerPC 86xx, 8641d Netlogic (formerly RMI) XLR, XLS QorIQ P20xx Altera MP32 QorIQ P4080 Key Features # Extensive multi-core and multiprocessing support: Use hardware to its fullest potential. VxWorks supports 32-bit and 64-bit multi-core processors based on Intel®, Arm®, Power, and RISC-V architectures. Its comprehensive processor support allows OS configurations for asymmetric multiprocessing (AMP), symmetric multiprocessing (SMP) with CPU affinity to address bound multiprocessing (BMP) scenarios, and hardware-optimized multi-core acceleration.\nOCI containers: Deploy applications at the speed of IT. Package and deploy all applications using IT-like tools and methods. Push your applications to standard container registries (such as Docker Hub, Amazon ECR, or Harbor) and pull them from your deployed VxWorks-based devices. Use Kubernetes for container orchestration.\nSecurity: Start with a foundation that adapts the security response to the threat. VxWorks integrates an extensive and continuously evolving set of security capabilities that map to the CIA triad. From booting operations to power down, these capabilities allow architects to develop a level of security appropriate for the attack surface and threats unique to their applications and environments.\nCertifiable: Meet regulatory requirements for your deployment. VxWorks has an extensive portfolio of safety certificationhistory, including 600+ programs with more than 360 individual customers. Its robust safety features provide advanced time and space partitioning capabilities to enable reliable consolidation of multiple applications with different levels of criticality on a single or multi-core platform. Additionally, conformance to standards such as POSIX® and the FACE™ Technical Standard have been leveraged in the certification of VxWorks to DO-178C, IEC 61508, IEC 62304, and ISO 26262 safety standards.\nRich connectivity and communications: Employ the broad range of communications necessary in a connected world. VxWorks supports IPv4 and IPv6 stacks, Routing Information Protocol (RIP), quality of service (QoS), and more. Additionally, VxWorks enables Time-Sensitive Networking (TSN), guaranteeing real-time communications and packet delivery within a bounded time or latency on a switched Ethernet network. VxWorks supports innovative industrial applications based on OPC Unified Architecture (OPC UA). It also supports SocketCAN, used in automotive applications, and provides host, target, and OTG USB support.\nBroad board support: Speed time-to-market by beginning from a solid starting point. Working with our ecosystem of partners, we have optimized VxWorks for the latest advanced processors and SOCs. It also includes the most extensive list of board support packages in the embedded software industry, providing early prototyping, cost savings, and flexibility of choice. Customization and tuning: Enjoy immense flexibility in customizing your product. Tailor your design to your specific needs with access to full source code, and/or use all the various configuration options to include or exclude predefined components and/or parameters.\nVirtualization: Choose from a number of flexible deployment options, from native to cloud. VxWorks is available as a guest operating system for a variety of virtualization environments, including but not limited to Wind River® Helix™ Virtualization Platform, QEMU, VMware, and KVM. Fault-tolerant file system: Take advantage of integrated fault tolerance. VxWorks comes with a fault-tolerant file system that can be certified.\nMultimedia: Benefit from out-of-the-box UI support. VxWorks offers support for many standard graphic libraries, such as OpenGL, OpenGL ES, OpenCV, and Vulkan, as well as libraries that handle JPEG and PNG images.\nAI/ML: Digital transformation and creation of added value/service are at your fingertips. Technologies such as pandas, Tensorflow Lite, and others are integrated to easily add AI/ML applications into the device.\nPython: Your access is out of the box and fully enabled. VxWorks supports Python, an easy-to-learn programming language that is ideal for quick prototyping, testing, and integrating high-level programs.\nFeedback loop: Enjoy digital transformation enablement. VxWorks comes with a variety of communication protocols allowing developers to collect device information and send it to the cloud for mining and analysis.\n","date":"2024-10-04","externalUrl":null,"permalink":"/","section":"VxWorks Overview","summary":"\u003cblockquote\u003e\nVxWorks The Leading RTOS\u003c/br\u003e\nThe industry's most widely deployed RTOS.\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.vxworks.net\" target=\"_blank\"\u003eVxWorks\u003c/a\u003e has been used to ensure the security, safety, and reliability you need to design and build mission-critical embedded systems that simply must work.\u003c/p\u003e","title":"VxWorks Overview","type":"page"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/workbench-4/","section":"Tags","summary":"","title":"Workbench 4","type":"tags"},{"content":"Workbench is an integrated development environment (IDE) that supports the construction of VxWorks projects.\nLearning Objectives # After this section you will be able to:\nDescribe what Workbench 4 is Describe how Workbench relates to the Eclipse IDE Navigate the layout of workbench What is Workbench 4 # Workbench 4 sits at the top of the ecosystem, bridging the integrated hardware, middleware, and software to develop VxWork projects.\nIt has a variety of tools in its arsenal:\nCompilers Project facilities Static debugging and analysis Dynamic debugging and analysis Target simulation Wind River Studio is another great option for working with and implementing VxWorks projects. Wind River Studio- The Platform For Intelligent Edge Systems\nWorkbench 4 is a Wind River product, but it runs off of a common platform.\nEclipse Framework # Workbench is based on the Eclipse platform. This is a popular IDE, with many intuitive design choices, making it easy to pick up and navigate. Eclipse is an open platform for tool integration that leverages open-source licensing and a community of tool developers. Workbench provides some powerful features from Eclipse, these include:\nAn open-source, standards-based framework for development tools integration A graphical user interface (GUI) framework and tool integration Open access, extensibility, and standardization Plug-in extensions and support C/C++ and Java development tools Connection menu This menu allows for you to set up connections with a target. This can be a real target or a simulator.\nProject Explorer In the Project Explorer you will find all your project files that are saved in workbench.\nDevelopment Window In this view, you can open and edit different files in your VxWorks project. This is the main workspace where you will spend a majority of your time in development.\nTerminal The terminal will allow you to execute commands and connect to the shell.\nPerspectives These are the perspective tabs. Workbench comes with a few premade ones.\nSome include:\nSystem Development System Viewer Debug Analysis Docker Tooling You can also access the perspectives by going to \u0026ldquo;Window \u0026gt; Perspective\u0026rdquo; on the tool bar.\nUtility Window This window contains different utility widgets. You can open specific ones, but most perspectives have certain widgets open by default.\nSome include:\nBreakpoints Debug Docker Containers Outline ","date":"2024-10-04","externalUrl":null,"permalink":"/training/workbench-4-overview/","section":"Free Training","summary":"\u003cp\u003eWorkbench is an integrated development environment (IDE) that supports the construction of VxWorks projects.\u003c/p\u003e","title":"Workbench 4 Overview","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/bsp/","section":"Board Support Package","summary":"","title":"Board Support Package","type":"bsp"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/training/","section":"Free Training","summary":"","title":"Free Training","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/container/","section":"Tags","summary":"","title":"Container","type":"tags"},{"content":"VxWorks is a robust operating system; it has many useful and powerful features for you to use in your project.\nLearning Objectives # After this section you will be able to:\nExplain the key features of VxWorks Understand the developer workflow using VxWorks Understand the use of containers in a VxWorks project Starting with any new software, it is important to know its capabilities. Once you know what the tool can do, you can make decisions on where you want your project to go.\nKey VxWorks Features # VxWorks is a robust operating system; it has many useful and powerful features for you to use in your project.\nA high-performance, memory protected, real-time operating system. Facilitates the run time environment for both kernel and user mode applications. Supports a variety of hardware architectures including, Intel, PowerPC, Arm, and RISC-V, and provides board support packages for the listed architectures. Works with simulation, some of the most common are VxSim, QEMU, and Simics. Provides CPU schedulers, such as priority, round-robin, time partition, and custom schedulers. Has boot loader support, common ones are VxBL, GRUB, U-Boot, UEFI, SYSLINUX, and PXE. An array of debugger tools, an error detection and reporting framework, core dump analytics, kernel debug, and a kernel shell. Works with peripherals, I/O, USB 3.0, serial and network connections, and graphics with OpenVG and Open GL ES stacks. While working on a project, rapid deployment is valuable. VxWorks can facilitate this with its container support.\nContainers in VxWorks # Containers are executable pieces of software for application code that are pre-loaded with dependencies. VxWorks utilizes Docker for distribution of its containers.\nEncapsulate RTP applications or application services, making them easier to distribute and run. The containers are distributed as binaries. This allows for them to have smaller footprints on the system than virtual machines. The hardware can support multiple CPU architectures. Implementing a developer workflow makes the project development process easier; a self-fulfilling process.\n","date":"2024-10-04","externalUrl":null,"permalink":"/training/vxworks-key-features/","section":"Free Training","summary":"\u003cp\u003eVxWorks is a robust operating system; it has many useful and powerful features for you to use in your project.\u003c/p\u003e","title":"VxWorks Key Features","type":"training"},{"content":"Wind River is a leader in the integrated software industry, providing tested and reliable products that work together in tandem with industry standards.\nA real-time solution for mission critical problems # What does Wind River offer # Wind River is a leader in the integrated software industry, providing tested and reliable products that work together in tandem with industry standards. When you need your embedded system to work, Wind River is here.\nVxWorks is one of the core components of the Wind River ecosystem, built for integrated hardware. Wind River Linux, on the other hand, provides tools to develop integrated software. At the very top of the ecosystem is Workbench, which is an Intergrated Developer Environment (IDE) where the code for VxWorks is created.\nVxWorks, an embedded real-time operating system # Discover the different tools and features you will learn about for your VxWorks projects.\nVxWorks Platform Features # The VxWorks platform utilizes a variety of components:\nArchitecture libraries, board support packages (BSP), and device drivers Kernel runtime environment and user space runtime environment The Portable Operating System Interface Connection through both serial and network connections Peripherals for the system to connect, including middleware, I/O, and multimedia. VxWorks Tools # VxWorks has a variety of tools and utilities:\nWorkbench 4 Compilers and debuggers Simulation tools, such as the built-in VxWorks simulator; VxSim Analytic tools, system viewer, and system browser Extensions for Visual Studio Code for Wind River Studio VxWorks Safety and Security # Wind River provides the following safety and security provisions:\nTime Partitioning User management, access control, and security event handler Secure boot and secure loader Encrypted containers Trusted platform module Network security But what if you need more # VxWorks has two additional, more robust versions.\nVxWorks 653 for avionics and defense, or ARINC 653 VxWorks Cert Edition for aerospace and defense DO-178C, industrial IEC 61508, or ISO 26262 safety standards These versions are typically used in aerospace or government projects. They have been designed meet certain safety requirements above and beyond what most consumer grade projects need.\nOther Products in the Wind River family # Wind River Studio # Wind River Studio is a cloud-native toolset for developing, deploying, operating, and servicing mission-critical intelligent systems across the edge.\nWind River Studio- The Platform For Intelligent Edge Systems\nCloud Platform # Wind River Studio Cloud Platform is an open source, production-grade distributed Kubernetes solution for managing cloud infrastructure.\nWind River Studio Cloud Platform | Kubernetes Solution\nWind River Linux # Wind River Linux is a purpose-built Linux operating system based on the open source Yocto project that enables you to develop, deploy, and operate robust, reliable, and secure embedded solutions.\nWind River Linux | A Custom Embedded Linux OS Builder\n","date":"2024-10-04","externalUrl":null,"permalink":"/training/the-wind-river-ecosystem/","section":"Free Training","summary":"\u003cp\u003eWind River is a leader in the integrated software industry, providing tested and reliable products that work together in tandem with industry standards.\u003c/p\u003e","title":"The Wind River Ecosystem","type":"training"},{"content":"","date":"2024-10-04","externalUrl":null,"permalink":"/tags/wind-river/","section":"Tags","summary":"","title":"Wind River","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]